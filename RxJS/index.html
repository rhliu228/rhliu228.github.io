<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>深入浅出RxJS总结 | Zoe的博客</title>
  
  

  
  <link rel="alternate" href="/atom.xml" title="Zoe的博客">
  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/css/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  
  <div class="cover-wrapper">
    <cover class="cover post half">
      
        
  <h1 class="title">Liu.Runhua</h1>


  <div class="m_search">
    <form name="searchform" class="form u-search-form">
      <input type="text" class="input u-search-input" placeholder>
      <i class="icon fas fa-search fa-fw"></i>
    </form>
  </div>

<div class="menu navgation">
  <ul class="h-list">
    
      
        <li>
          <a class="nav home" href="/" id="home">
            <i class="fas fa-rss fa-fw"></i>&nbsp;博文
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/about/" rel="nofollow" id="about">
            <i class="fas fa-info-circle fa-fw"></i>&nbsp;关于
          </a>
        </li>
      
    
  </ul>
</div>

      
    </cover>
    <header class="l_header pure">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="pure"></div>
  </div>

	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          Zoe的博客
        
      </a>
			<div class="menu navgation">
				<ul class="h-list">
          
  					
  						<li>
								<a class="nav flat-box" href="/blog/tags/" rel="nofollow" id="blogtags">
									<i class="fas fa-hashtag fa-fw"></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/archives/" rel="nofollow" id="blogarchives">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
        
          <li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/" id="home">
								<i class="fas fa-clock fa-fw"></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/blog/archives/" rel="nofollow" id="blogarchives">
								<i class="fas fa-archive fa-fw"></i>&nbsp;文章归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/" rel="nofollow" id="about">
								<i class="fas fa-info-circle fa-fw"></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      <div class="l_main">
  

  
    <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
      


  <section class="meta">
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/RxJS/">
        深入浅出RxJS总结
      </a>
    </h1>
  


      
      <div class="new-meta-box">
        
          
        
          
            
  <div class="new-meta-item author">
    <a href="https://rhliu228.github.io." rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Liu.Runhua</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class="notlink">
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-03-15</p>
  </a>
</div>

          
        
          
            

          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class="notlink">
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          <p>很早就在一些博客和书籍上了解到，javascript是一门具备函数式编程特性的语言，虽然在日常工作也会接触到js的闭包，函数绑定，函数柯里化等概念，但对于函数式编程的特点和优势，一直一知半解。加之在工作中总会遇到异步处理的糟糕代码，所以前段时间花了一些功夫在阅读程墨著作的《深入浅出RxJS》上。总的来说，RxJS是Reactive Extension(也叫ReactiveX)编程理念的javascript版本。Reactive Extension是实践响应式编程的一套工具，其诞生的主要目的是解决异步处理的问题，但这并不表示Rx不适合同步的数据处理。这篇文章主要总结自己阅读《深入浅出RxJS》的一些思考，关于RxJS的具体使用可参考<a href="http://reactivex.io/" target="_blank" rel="noopener">ReactiveX</a>。<br><a id="more"></a></p>
<h2 id="函数响应式编程"><a href="#函数响应式编程" class="headerlink" title="函数响应式编程"></a>函数响应式编程</h2><p>RxJS引用了两个重要的编程思想：函数式和响应式</p>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>函数式编程是强调使用函数来解决问题的一种编程范式。其对函数的使用有一些特殊的要求： </p>
<ul>
<li><p>声明式<br>和声明式编程相对的是命令式编程，命令式编程强调将计算逻辑以指令的方式描述出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function double(arr)&#123;</span><br><span class="line">    const result = [];</span><br><span class="line">    for(let i =0; i&lt;arr.length; i++) &#123;</span><br><span class="line">        result.push(arr[i]*2);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  而声明式编程则把运算过程尽量写成一系列嵌套的函数调用：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const double = arr =&gt; arr.map(item =&gt; item * 2);</span><br></pre></td></tr></table></figure>
<p>  在javascript中，函数具有一等公民的地位，一个函数可以作为参数传递给另一个函数，才让map这种功能实现成为了可能。</p>
</li>
<li>纯函数<br>所谓纯函数，满足了以下条件</li>
</ul>
<ol>
<li>函数的执行过程完全由输入参数决定，不会受除参数之外的任何数据影响.</li>
<li>函数不会修改任何外部状态，比如修改全局变量或传入的参数对象.</li>
</ol>
<ul>
<li>数据不变性<br>程序要发生变化，不应该修改现有的数据，而是应该通过产生新的数据来体现这种变化。不可变的数据就是Immutable的数据。</li>
</ul>
<p>  顺便对比一下函数式编程和面向对象编程。这两种编程方式都可以让代码更加容易理解，但方式不同。面向对象的方法把状态的改变封装起来，外部不能直接操作数据，只能通过类提供的实例方法来读取修改数据，限制了对数据的访问方式，这就制止了毫无节制的数据修改。但是面向对象却把数据的修改历史完全隐藏起来，这种不确定性导致代码可维护性下降。而函数式编程则是尽量减少发生变化的部分，数据就是数据，函数就是函数，函数可以处理数据，通过产生新的数据作为运算结果，以此让代码更加清晰。<br>  从本质上说，javascript并不是纯粹意义的函数式编程语言，javascript并没有强制要求数据不变性，编写的函数也不能保证没有副作用，但是javascript的函数拥有第一公民的身份，由此可以很方便地应用函数式编程的许多思想。<br>More info:<br><a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html" target="_blank" rel="noopener">函数式编程入门教程</a><br><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="noopener">函数式编程初探</a></p>
<h3 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h3><blockquote>
<p>响应式编程是一种面向数据流和变化传递的编程范式。</p>
</blockquote>
<p>数据流可以通过多种方式创造出来，流对象中流淌的是数据，数据流会通过各种管道，这些管道会对数据进行各种转化处理，RxJS的核心就是使用和组合各种操作符，构成管道，对流经其中的数据进行处理。</p>
<h2 id="Observable-和Observer"><a href="#Observable-和Observer" class="headerlink" title="Observable 和Observer"></a>Observable 和Observer</h2><p>Observer和Obeservable是RxJS的两个重要概念。Obeservable就是“可被观察的对象”，而Observer就是观察者，连接两者的桥梁就是Observable对象的函数subscribe。<br>每个Observable对象，代表的就是在一段时间范围内发生的一系列事件。RxJs结合了观察者模式和迭代器模式，其中的Observable等同于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable = Publisher + Iterator</span><br></pre></td></tr></table></figure>
<ul>
<li>观察者模式<br>观察者模式将逻辑分为发布者和观察者，其中生产者只负责产生事件，它会通知所有注册挂上号的观察者，而不关心这些观察者如何处理这些事件，相对的，观察者可以被注册上某个发布者，只管接收到事件之后就处理，而不关心这些数据是如何产生的。在RxJS的世界中，Observable对象就是一个发布者，通过Observable对象的subscribe，可以把这个发布者和某个观察者连接起来。<br>观察者使得复杂的问题被分解成三个小问题：</li>
</ul>
<ol>
<li>如何产生事件，这是发布者的责任，在RxJS中是Observable对象的工作。</li>
<li>如何响应事件，这是观察者的责任，在RxJS中由subscribe的参数来决定。</li>
<li>什么样的发布者关联什么样的观察者，也就是何时调用subscribe。</li>
</ol>
<ul>
<li>迭代器模式<br>迭代器指的是能够遍历一个数据集合的对象，数据集合的实现方式有很多，比如数组，单向链表等，迭代器的作用就是提供一个通用的接口，让使用者完全不用关心这个数据集合的集合的实现方式。<br>迭代器的另一个名字叫游标（cursor）,就像一个移动的指针一样，从集合中的一个元素移动到另一个元素，完成对整个集合的遍历。<br>迭代器的实现方式有很多，通常包含以下几个函数： </li>
</ul>
<ol>
<li>getCurrent，获取当前被游标指向的元素</li>
<li>moveToNext，将游标移动到下一个元素，调用这个函数之后，getCurrent获得的元素就会不同</li>
<li>isDone， 判断是否已经遍历完所有的元素<br>上面说的三个函数，是“拉”式迭代器的实现，而RxJs实现的是“推”式的迭代器的实现。因为在RxJS中，作为迭代器的使用者，并不需要主动从Observable中“拉”数据，而是只要subscribe上Observable对象之后，自然就能接收到消息的推送，这就是观察者模式和迭代器模式结合的强大之处。<br>下面是一段代码：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const iterator = getIterator();</span><br><span class="line">while(!iterator.isDone())&#123;</span><br><span class="line">    console.log(iterator.getCurrent());</span><br><span class="line">    iterator.moveToNext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下这段代码说明了Observable在完结，出错处理以及向下游传递数据时如何通知下游。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">const onSubscribe = observer =&gt; &#123;</span><br><span class="line">    let number = 1;</span><br><span class="line">    const handle = setInterval(() =&gt; &#123;</span><br><span class="line">        observer.next(number++);</span><br><span class="line">    &#125;,1000);</span><br><span class="line">    return &#123;</span><br><span class="line">        unsubscribe: () =&gt; &#123;</span><br><span class="line">            clearInterval(handle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 完结和出错处理</span><br><span class="line">const onSubscribe = observer =&gt; &#123;</span><br><span class="line">    observer.next(1);</span><br><span class="line">    // 向下游传递完结信号</span><br><span class="line">    observer.complete();</span><br><span class="line">    // or 向下游传递错误信号</span><br><span class="line">    //注意，一个Observable对象只能有一种终结状态，要么是完结，要么是出错，所以调用了complete之后再调用error函数是无法引发下游的错误处理函数调用的，反之亦然。</span><br><span class="line">    //observer.error(&apos;wrong&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const source$ = new Observable(onSubscribe);</span><br><span class="line">const theObserver = &#123;</span><br><span class="line">    next: item =&gt; console.log(item),</span><br><span class="line">    error: err =&gt; console.log(err),</span><br><span class="line">    complete: () =&gt; console.log(&apos;No more Data)</span><br><span class="line">&#125;</span><br><span class="line">const subscription = source$.subscribe(theObserver);</span><br><span class="line">// 也可以简写为</span><br><span class="line">// const subscription = source$.subscribe(</span><br><span class="line">//    item =&gt; console.log(item),</span><br><span class="line">//    err =&gt; console.log(err),</span><br><span class="line">//    complete: () =&gt; console.log(&apos;No more Data)</span><br><span class="line">//);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    //退订Observable</span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">&#125;,3500);</span><br></pre></td></tr></table></figure></p>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>一个Observable对象代表的是一个数据流，实际工作中，产生Observable对象并不是每次都直接调用Observable构造函数来创建数据流对象，Rxjs已经贴心地为我们实现了常用的创建类操作符。这里说的创造，并不只是说返回一个Observable对象，而是指这些操作符不依赖于其他Observable对象，这些操作符可以凭空或者根据其他数据源（外部js事件，promise，ajax等）创造出一个Observable对象。事实上，对于复杂情况，并不会创建了一个数据流之后就直接subscribe一个Observer，往往需要各类操作符对数据流做一系列的处理，再交给Observer，就像一个管道，数据从管道的一段流入，途经管道的各个环节，位于管道末端的Observer只需要处理能够走到终点的数据。<br>  组成数据管道的元素就是操作符，操作符的本质是返回一个Observable对象的函数。对于每一个管道，链接的就是上游和下游。<br>  在数据管道中流淌的数据就像水，从上游流向下游。对于一个操作符来说，上游可能是一个数据源，也可能是其他操作符，下游可以是最终的观察者，也可能是另一个操作符。每个操作符都会满足</p>
<ol>
<li>返回一个全新的Observable对象</li>
<li>对上游和下游的订阅和退订处理。</li>
<li>处理异常情况</li>
<li>及时释放资源</li>
</ol>
<h3 id="操作符分类"><a href="#操作符分类" class="headerlink" title="操作符分类"></a>操作符分类</h3><h4 id="功能分类"><a href="#功能分类" class="headerlink" title="功能分类"></a>功能分类</h4><p>根据功能，操作符可以分为以下类别</p>
<ul>
<li>创建类，包括create, of, range, generate, repeat和repeatWhen, empty, throw, never, inteval和timer, from, from Promise, from event和fromEventPattern, ajax, defer.</li>
<li>转化类，包括map, mapTo, pluck, windowTime、 windowCount、windowWhen、windowToggle、和window, bufferTime、bufferCount、bufferWhen、bufferToggle和buffer, concatMap、mergeMap、switchMap、exhaustMap, scan和mergeScan</li>
<li>过滤类，包括filter, first, last, take, takeLast, takeWhile和takeUntil, skip, skipwhile和skipUntil, throttleTime、debouceTime和auditTime, throttle、debouce和audit, sample和sampleTime, distnct, distinctUntilChanged和distinctUntilKeyChanged, ignoreElements, elementAt, single</li>
<li>合并类，包括concat和concatAll, merge和mergeAll, zip和zipAll, combineLatest、combineAll和withLatestFrom, race, startWith, forkJoin, switch和exhaust</li>
<li>多播类，包括multicast, publishLast, publishReplay, publishBehavior</li>
<li>错误处理类，包括catch, retry和retryWhen, finally</li>
<li>辅助工具类，包括concat, max和min, Reduce, every, find和findIndex, isEmpty, defaultEmpty</li>
</ul>
<h4 id="静态和实例分类"><a href="#静态和实例分类" class="headerlink" title="静态和实例分类"></a>静态和实例分类</h4><p>  操作符还可以从存在形式进行分类，具体来说就是操作符的实现函数和Observable类的关系。对于定义在Observable类的静态函数，我们称之为静态操作符，而定义在由Observable类prototype属性指向的原型对象上的实例函数，则被称为实例操作符。在链式调用中，静态操作符只能出现在首位，而实例操作符可以出现在任何位置。有些操作符既可以作为Observable类的静态方法，又可以作为Observable对象的实例方法，比如merge。（此处涉及javascript的原型链知识以及es6的class，建议不太了解的读者查阅其他资料了解）</p>
<h3 id="操作符的实现"><a href="#操作符的实现" class="headerlink" title="操作符的实现"></a>操作符的实现</h3><h4 id="操作符函数实现"><a href="#操作符函数实现" class="headerlink" title="操作符函数实现"></a>操作符函数实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function map(project) &#123;</span><br><span class="line">    return new Observable(observer =&gt; &#123;</span><br><span class="line">        const sub = this.subscribe(&#123;</span><br><span class="line">            next: value =&gt; &#123;</span><br><span class="line">                //处理异常情况</span><br><span class="line">                try&#123;</span><br><span class="line">                    observer.next(project(value))</span><br><span class="line">                &#125; catch(err) &#123;</span><br><span class="line">                    observer.error(error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            error: error =&gt; observer.error(error),</span><br><span class="line">            complete: () =&gt; observer.complete()</span><br><span class="line">        &#125;);</span><br><span class="line">        //订阅和退订处理</span><br><span class="line">        return &#123;</span><br><span class="line">            unsubscribe: () =&gt; &#123;</span><br><span class="line">                sub.unsubscribe();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">//使用es6箭头函数将会出错，因为此时this将直接绑定为定义函数环境下的this</span><br><span class="line">//const map = (project) =&gt; &#123;</span><br><span class="line">    //这个函数体内的this并不是Observable对象本身</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，map利用new关键字创造了一个Observable对象，函数返回的结果就是这个对象，如此一来，map可以链式调用，可以在后面调用其他的操作符，或者调用subscribe增加Observer。这里的this代表的是上游的Observer对象，所以，可以直接使用subscribe订阅其中的事件，对于next事件，调用project函数，把推送的数据做映射，然后传递给下游，对于error和complete事件，map全部转手给下游处理。</p>
<h4 id="操作符关联Observable"><a href="#操作符关联Observable" class="headerlink" title="操作符关联Observable"></a>操作符关联Observable</h4><p>map函数编写完毕之后，需要将这个函数与observable关联起来。</p>
<ol>
<li>给Observable打补丁<br>打补丁就像是给Observable类添加一点功能。<br>map操作符需要一个上游Observable对象，所以它是一个实例操作符，需要赋值给Observable的prototype：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.map = mao;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果是一个静态操作符，则直接赋给Observable类的某个属性。</p>
<ol start="2">
<li>使用bind绑定Observable对象<br>有时候，我们并不希望一个操作符影响所有的Observable对象，为了不覆盖RxJS的map操作符，可以让自定义的操作符只对指定的Observable对象可用，这时可以用bind：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const result$ = map.bind(source$)(x =&gt; x*2);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>也可以用call：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const result$ = map.call(source$,x =&gt; x*2);</span><br></pre></td></tr></table></figure></p>
<p>使用bind有一个缺点，就是上游Observable只能作为操作符函数的参数，这样没法用链式调用，比如，想要连续使用两个map：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const result$ = map.bind(map.bind(source$)(x =&gt; x*2))(x =&gt; x+1);</span><br></pre></td></tr></table></figure></p>
<p>为了克服这个缺点，可以使用“绑定操作符”，绑定操作符是两个冒号，运算的时候绑定操作符后面的函数，但是保证函数运行时this是绑定操作符前面的对象，这样就可以使用链式调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const result$ = source$::map(x=&gt;x*2)::map(x=&gt;x+1);</span><br></pre></td></tr></table></figure></p>
<p>绑定操作符并不是es6的标准语法，但它会出现在未来的es版本中，浏览器并不支持这种操作符。</p>
<ol start="3">
<li>使用lift<br>RxJS v5对架构有很大的调整，很多操作符都会用一个神奇的lift函数实现，lift的含义是“提升”，功能是把Observable对象提升一个层次，赋予更多功能。lift是Observable的实例函数，它会返回一个新的Observable对象，通过传递给lift的函数参数可以赋予这个新的Observable对象特殊功能。<br>使用lift实现map： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function map(project) &#123;</span><br><span class="line">    return this.lift(function(source$) &#123;</span><br><span class="line">        return source$.subscribe(&#123;</span><br><span class="line">            next: value =&gt; &#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    this.next(project(value))</span><br><span class="line">                &#125; catch(err) &#123;</span><br><span class="line">                    this.error(error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            error: err =&gt; this.error(err),</span><br><span class="line">            complete: () =&gt; this.complete(),</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>this代表的是Observer对象，参数source$代表上游的Observable对象。</p>
<h3 id="改进的操作符定义"><a href="#改进的操作符定义" class="headerlink" title="改进的操作符定义"></a>改进的操作符定义</h3><h4 id="操作符和Observable关联的缺陷"><a href="#操作符和Observable关联的缺陷" class="headerlink" title="操作符和Observable关联的缺陷"></a>操作符和Observable关联的缺陷</h4><p>js模块导入的代码并不都会被执行，打包工具（rollup，webpack等）的Tree shaking主要用于在js代码打包过程中去除无用的死代码，减少js代码的体积。<br>RxJS中操作符挂在Observable类上或者Observable.prototype上，赋值给Observable类和Observable.prototype上的某个属性在Tree shaking看来就是就是有用的代码，所以，所有的操作符，不管真实运行时是否被调用，都会被Tree shaking认为是有用的代码，不会被当作死代码删除。<br>比如，代码引入interval和map两个操作符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &apos;rxjs/add/observable/interval&apos;;</span><br><span class="line">import &apos;rxjs/add/operator/map&apos;;</span><br></pre></td></tr></table></figure></p>
<p>假如在程序中interval和map并没有被调用过，这两个操作符也不会被当作死代码。<br>除此之外，用给Observable打补丁的方式导入操作符，每个文件模块影响的都是全局唯一的那个Observable，极其容易因为代码耦合造成问题。</p>
<h4 id="使用call来创建库"><a href="#使用call来创建库" class="headerlink" title="使用call来创建库"></a>使用call来创建库</h4><p>摒弃给Observable类打补丁的做法，对于静态操作符，直接使用该函数即可，对于实例操作符，使用bind/call方法，让一个操作符只对一个具体的Observable对象生效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//留意导入路径的不同</span><br><span class="line">import &#123;Observable&#125; from &apos;rxjs/Observable&apos;;</span><br><span class="line">import &#123;of&#125; &apos;rxjs/observable/of&apos;;</span><br><span class="line">import &#123;map&#125; &apos;rxjs/operator/map&apos;;</span><br><span class="line">Observable.prototype.double = function() &#123;</span><br><span class="line">    return this::map(x =&gt; x*2);</span><br><span class="line">&#125;</span><br><span class="line">const source$ = of(1,2,3);</span><br><span class="line">const result$ =source$.double();</span><br><span class="line">result$.subscribe(value =&gt; console.log(value));</span><br></pre></td></tr></table></figure></p>
<p>上述代码导入的of和map是两个独立的函数，RxJs传统的打补丁的方式，使用的也是observable和operator目录下的代码，例如rxjs/add/observable/of.js文件所做的工作就是导入rxjs/observable/of.js，并把导入的函数挂载到Observable类上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var Observable__1 = require(&apos;../../Observable&apos;);</span><br><span class="line">var of_1 = require(&apos;../../observable/of&apos;);</span><br><span class="line">Observable__1.Observable.of = of_1.of;</span><br></pre></td></tr></table></figure></p>
<p>使用bind和call方法，避免了Observable被污染的问题。</p>
<h4 id="lettable和pipeable操作符"><a href="#lettable和pipeable操作符" class="headerlink" title="lettable和pipeable操作符"></a>lettable和pipeable操作符</h4><p>使用bind和call，每个函数体内依然需要访问this，访问this的函数并不是纯函数。另外，使用call也会让RxJS的代码失去类型检查的优势。从RxJS v5.5.0开始，加入了pipeable操作符，也曾称为lettable操作符。</p>
<ol>
<li>let<br>在lettable操作符提出之前，let操作符就存在了，它接受一个函数作为参数，该函数需要接收一个Observable对象作为上游Observable。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Observable&#125; from &apos;rxjs/Observable&apos;;</span><br><span class="line">import &apos;rxjs/add/observable/of&apos;;</span><br><span class="line">import &apos;rxjs/add/operator/map&apos;;</span><br><span class="line">import &apos;rxjs/add/operator/let&apos;;</span><br><span class="line">const source$ = Observable.of(1,2,3);</span><br><span class="line">//double$是一个纯函数，map直接作用于参数obs$</span><br><span class="line">const double$ = obs$ =&gt;obs$.map(x=&gt;x*2);</span><br><span class="line">const result$ = source$.let(double$);</span><br><span class="line">result$.subscribe(console.log);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>改进以上代码，让map返回一个函数，从而可以作为let操作符的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function map(project) &#123;</span><br><span class="line">    return function(obs$)&#123;</span><br><span class="line">        return new Observable(observer =&gt; &#123;</span><br><span class="line">            return obs$.subscribe(&#123;</span><br><span class="line">                next: value =&gt; &#123;</span><br><span class="line">                    //处理异常情况</span><br><span class="line">                    try&#123;</span><br><span class="line">                        observer.next(project(value))</span><br><span class="line">                    &#125; catch(err) &#123;</span><br><span class="line">                        observer.error(error);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                error: error =&gt; observer.error(error),</span><br><span class="line">                complete: () =&gt; observer.complete()</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const result$ = source$.let(map(x=&gt;x*2));</span><br></pre></td></tr></table></figure></p>
<p>let的作用是把map函数引入到链式调用之中，起到连接上游下游的作用。这里的map函数执行不再是返回一个Observable对象，而是返回一个函数，这个函数才返回Observable对象。，map的实现也看不到对this的访问，在数据管道中上游Observable对象以参数形式传入，而不是靠this获取，让map成为了一个纯函数。<br>从RxJS v5.5.0开始，加入了pipeable操作符，大部分操作符都有pipeable操作符实现，除了：</p>
<ol>
<li>静态操作符</li>
<li>拥有多个上游Observable对象的操作符</li>
</ol>
<p>因为每一个lettable操作符都是纯函数，且不会作为补丁挂在Observable类上，Tree shaking就能够找到根本不会被用到的操作符并将其去除。但是导入let这个操作符，却需要使用传统的打补丁的形式，所以RxJS让Observable类自带了一个新的操作符，名叫pipe，可以满足let的功能，却不需要像使用let一样导入模块，任何Observable对象都支持pipe<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const result$ = source$.pipe(map(x=&gt;x*2));</span><br></pre></td></tr></table></figure></p>
<p>pipe还具有管道的功能，可以把多个lettable操作符连接起来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123;of&#125; &apos;rxjs/observable/of&apos;;</span><br><span class="line">//留意lettable操作符的引入路径</span><br><span class="line">import &#123;map,filter&#125; &apos;rxjs/operators&apos;;</span><br><span class="line">const source$ = of(1,2,3);</span><br><span class="line">const result$ = source$.pipe(</span><br><span class="line">    filter(x =&gt; x%2 ===0),</span><br><span class="line">    map(x =&gt; x*2)</span><br><span class="line">);</span><br><span class="line">result$.subscribe(console.log);</span><br></pre></td></tr></table></figure></p>
<p>有四个操作符比较特殊，传统的操作符名称和pipeable操作符名称不同：</p>
<ul>
<li>do</li>
<li>catch</li>
<li>switch</li>
<li>finally<br>这四个操作符名称都是js的关键字，以打补丁的方式赋值为Observable.prototype对象某个属性值没有问题，但是不能作为函数的标识符出现，这四个操作符对应的lettable操作符分别是</li>
<li>tap</li>
<li>catchError</li>
<li>switchAll</li>
<li>finalize</li>
</ul>
<h2 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h2><p>在RxJs中，Observable和Observer的关系，就是前者在播放内容，后者在收听内容，播放内容的方式可以分为三种：</p>
<ul>
<li>单播（unicast）</li>
<li>广播（broadcast）</li>
<li>多播（multicast）<br>单播是一对一的关系，一个播放者对应一个接听者，广播把消息传播给所有接听者，多播则是有选择性地把消息传递给有需要的接听者。RxJS对单播是绝对支持的，而广播则不是RXJS支持的目标，广播已经有很多现成的解决方法，例如nodeJs中的EventEmitter。</li>
</ul>
<h3 id="Hot和Cold数据流的差异"><a href="#Hot和Cold数据流的差异" class="headerlink" title="Hot和Cold数据流的差异"></a>Hot和Cold数据流的差异</h3><p>如果每一次观察者对Observable对象进行subscribe，都会产生一个全新的数据序列的数据流，这样的Observable对象被称为cold observable。RxJS的大部分创建类操作符创建出来的都是cold observable对象，例如inteval，range等。<br>下面是一个单播的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123;interval&#125; &apos;rxjs/observable/of&apos;;</span><br><span class="line">import &#123;take&#125; &apos;rxjs/operators&apos;;</span><br><span class="line">const tick$ = interval(1000).pipe(take(3));</span><br><span class="line">tick$.subscribe(value=&gt;console.log(&apos;observer 1: &apos; + value));</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    tick$.subscribe(value=&gt;console.log(&apos;observer 2: &apos; + value));</span><br><span class="line">&#125;,2000);</span><br><span class="line"></span><br><span class="line">//console</span><br><span class="line">//observer 1: 0</span><br><span class="line">//observer 1: 1</span><br><span class="line">//observer 2: 0</span><br><span class="line">//observer 1: 2</span><br><span class="line">//observer 2: 1</span><br><span class="line">//observer 2: 2</span><br></pre></td></tr></table></figure></p>
<p>你可能会以为输出下面的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//observer 1: 0</span><br><span class="line">//observer 1: 1</span><br><span class="line">//observer 2: 1</span><br><span class="line">//observer 1: 2</span><br><span class="line">//observer 2: 2</span><br></pre></td></tr></table></figure></p>
<p>但是，interval操作符产生的是一个cold observable对象，每次对上游的subscribe都会产生一个新的生产者。<br>而对于一个hot observable，概念上有一个独立于Observable对象的生产者，这个生产者的创建与subscribe的调用没有关系，subscribe的调用只是让Observable对象连接上生产者而已。RxJs中有一些操作符产生的是Hot Observable：</p>
<ul>
<li>fromPromise</li>
<li>fromEvent</li>
<li>fromEventPattern</li>
</ul>
<p>这些产生hot observable对象的操作符数据源都在外部，真正的数据源和有没有Observer没有任何关系。而真正的多播，则是不管有多少Observer进行subscribe，推给Observer的数据都是一样的数据源，满足这种条件的，就是hot observable。<br>hot observable和cold observable都具有“懒”的性质，两者的数据管道内逻辑都只有订阅者存在时才执行，但是cold Observable更“懒”，如果没有订阅者，连数据都不会真正产生；对于hot observable来说，没有订阅者的情况下，数据依旧产生，只是不传入数据管道。<br>所以cold observable实现的是单播，而hot observable实现的是多播。</p>
<h3 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h3><p>有时候，我们也希望对cold observable实现多播。要把一个cold observable对象转换成一个hot observable，并不是去改变cold observable本身，而是产生一个新的observable对象，包装之前的cold observable对象，这样在数据流管道中，新的observable就成为了下游。<br>要实现这个转化，很明显需要一个“中间人”做串接的事情：</p>
<ul>
<li>中间人需要提供subscribe方法，让其他人能够订阅自己的数据源</li>
<li>中间人能够有办法接收推送的数据，包括cold observable推送的数据<br>RxJS中，提供了subject类型，subject既有observable的接口，也具有observer的接口。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Subject&#125; from &apos;rxjs/Subject&apos;;</span><br><span class="line">import &#123;interval&#125; &apos;rxjs/observable/interval&apos;;</span><br><span class="line">import &#123;map&#125; &apos;rxjs/operators&apos;;</span><br><span class="line">const subject = new Subject();</span><br><span class="line">subject.pipe(map(x=&gt;x*2)).subscribe(</span><br><span class="line">    value =&gt; console.log(value),</span><br><span class="line">    err =&gt; console.log(err),</span><br><span class="line">    () =&gt; console.log(&apos;on complete&apos;)</span><br><span class="line">);</span><br><span class="line">subject.next(1);</span><br><span class="line">subject.next(2);</span><br><span class="line">subject.complete();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>一个subject对象是一个Observable，所以可以在后面链式调用任何操作符，也可以调用subscribe来添加Observer。<br>一个subject对象同时也是一个Observer，所以也支持next，error和complete方法。</p>
<h3 id="用Subject实现多播"><a href="#用Subject实现多播" class="headerlink" title="用Subject实现多播"></a>用Subject实现多播</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Subject&#125; from &apos;rxjs/Subject&apos;;</span><br><span class="line">import &#123;interval&#125; &apos;rxjs/observable/interval&apos;;</span><br><span class="line">import &#123;map&#125; &apos;rxjs/operators&apos;;</span><br><span class="line">const tick$ = interval(1000).pipe(take(3));</span><br><span class="line">const subject = new Subject();</span><br><span class="line">tick$.subscribe(subject);</span><br><span class="line">subject.subscribe(value=&gt;console.log(&apos;observer 1: &apos; + value));</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    subject.subscribe(value=&gt;console.log(&apos;observer 2: &apos; + value));</span><br><span class="line">&#125;,1500);</span><br></pre></td></tr></table></figure>
<p>只需要让Subject对象居于cold observable和observer之间。<br>但是很可惜subject并不是一个操作符，所以无法链式调用，不过可以创建一个新的操作符来达到链式调用的效果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.makeHot = function() &#123;</span><br><span class="line">    const cold$ = this;</span><br><span class="line">    const subject = new Subject();</span><br><span class="line">    cold$.subscribe(subject);</span><br><span class="line">    return subject;</span><br><span class="line">&#125;</span><br><span class="line">const hotTick$ = interval(1000).pipe(take(3)).makeHot();</span><br><span class="line">hotTick$.subscribe(value=&gt;console.log(&apos;observer 1: &apos; + value));</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    hotTick$.subscribe(value=&gt;console.log(&apos;observer 2: &apos; + value));</span><br><span class="line">&#125;,1500);</span><br></pre></td></tr></table></figure></p>
<p>这段代码有个漏洞，可以直接调用makeHot返回的subject对象的next，error或者complete方法来影响下游：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const hotTick$ = interval(1000).pipe(take(3)).makeHot();</span><br><span class="line">hotTick$.complete();</span><br><span class="line">//下面的Observer将不会收到任何消息</span><br><span class="line">hotTick$.subscribe(value=&gt;console.log(&apos;observer 1: &apos; + value));</span><br></pre></td></tr></table></figure></p>
<p>subject对象是不能重复使用的，一个subject对象一旦被调用了complete或者error函数，那么，它作为observable的生命周期也就结束了，后续再想利用这个subject对象传递数据给下游，就像泥牛如大海，没有任何反应。<br>为了杜绝这种可能性，对makeHot进行改进，让它返回一个纯粹的Observable对象:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.makeHot = function() &#123;</span><br><span class="line">    const cold$ = this;</span><br><span class="line">    const subject = new Subject();</span><br><span class="line">    cold$.subscribe(subject);</span><br><span class="line">    return Observable.create((observer) =&gt; subject.subscribe(observer));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>makeHot并不是直接返回Subject对象，而是返回一个新的Observable对象，这样就避免了subject直接暴露给外部。</p>
<p>subject可以有多个上游，如果一个subject订阅多个数据流，起到的作用就是把多个数据源的内容汇聚到一个observable，但是这种使用方式却可能引发意想不到的结果。假设其中一个上游调用了subject对象的complete函数，那即使其他上游的数据还没推送完，subject也会因为生命周期的结束，无法再把其他数据推送给下游。<br>任何一个上游数据的完结或者出错都可以终结subject对象的生命，让subject来做合并数据流的工作并不合适，应该让merge来做。<br>当subject有多个observer时，如果某个observer产生了一个错误异常，而且这个异常没有被observer处理，那subject的其他observer都会失败。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const tick$ = interval(1000).pipe(take(3));</span><br><span class="line">const subject = new Subject();</span><br><span class="line">tick$.subscribe(subject);</span><br><span class="line">const throwOnUnluckyNumber = value =&gt; &#123;</span><br><span class="line">    if(value==4)&#123;</span><br><span class="line">        throw new Error(&apos;unlucky number 4&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line">subject.pipe(map(throwOnUnluckyNumber)).subscribe(</span><br><span class="line">    value=&gt;console.log(&apos;observer 1: &apos; + value)</span><br><span class="line">)</span><br><span class="line">subject.subscribe(</span><br><span class="line">    value=&gt;console.log(&apos;observer 2: &apos; + value),</span><br><span class="line">    err=&gt;console.log(err)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>1号observer在遇到数字4的时候遇到错误异常，2号observer因为1号observer没有优雅地处理错误，也被牵连，因为subject对象由于下游1号Observer没有处理错误而被破坏了。<br>可以想象，Subject为了给所有observer推送数据，会有类似的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(let observer of allObservers)&#123;</span><br><span class="line">    observer.next(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了解决这个问题，好的编程实践是让所有的observer都具备对异常错误的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">subject.pipe(map(throwOnUnluckyNumber)).subscribe(</span><br><span class="line">    value=&gt;console.log(&apos;observer 1: &apos; + value),</span><br><span class="line">    err=&gt;console.log(&apos;observer 1 on error: &apos; + err)</span><br><span class="line">)</span><br><span class="line">subject.subscribe(</span><br><span class="line">    value=&gt;console.log(&apos;observer 2: &apos; + value),</span><br><span class="line">    err=&gt;console.log(&apos;observer 2 on error: &apos; + err)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h3 id="支持多播的操作符"><a href="#支持多播的操作符" class="headerlink" title="支持多播的操作符"></a>支持多播的操作符</h3><p>RxJs提供了支持多播的一系列操作符，其中最基础的是</p>
<ul>
<li>multicast</li>
<li>share </li>
<li>publish</li>
</ul>
<ol>
<li>multicast是一个实例操作符，能够以上游的Observable为数据源产生一个新的hot observable对象：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const hotSource$ = coldSource$.multicast(new Subject);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>multicast接收一个subject对象或者一个返回subject对象的函数（可以在subject对象生命终结时重新subscribe上游）作为参数，<br>返回的是一个Observable对象，不过这个对象比较特殊，是Observable子类ConnectableObservable的实例对象。这种对象包含一个connect函数，connect的作用是<br>触发multicast用Subject对象去订阅上游的Observable，如果不调用这个函数，这个ConnectableObservable将不会从上游那里得到任何数据。<br>除此之外，ConnectableObservable还支持自动计数，对Observer的个数进行计数，当第一个Observer对象被添加时，主动去订阅上游，当最后一个Observer退订时，就让中间人<br>Subject退订上游的Cold Observable。这个功能可以借助ConnectableObservable对象的函数refCount实现。<br>除了第一个参数指定一个Subject对象或者指定一个产生Subject对象的工厂方法，multicast还支持第二个参数：selector，这个参数是一个可选参数，它可以使用上游数据任意多次，但不会重复订阅上游数据流。<br>一旦指定selector参数，multicast将不会返回ConnectableObservable对象，而是用selector函数来产生一个Observable对象。<br>selector函数有一个参数shared，这个参数就是multicast第一个参数代表的Subject或者使用工厂方法返回的Subject对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const coldSource$ = interval(1000).pipe(take(3));</span><br><span class="line">const selector = shared =&gt; &#123;</span><br><span class="line">    return shared.pipe(concat(of(&apos;done)));</span><br><span class="line">&#125;</span><br><span class="line">const tick$ = coldSource$.pipe(multicast(new Subject(),selector));</span><br><span class="line">tick$.subscribe(</span><br><span class="line">    value=&gt;console.log(&apos;observer 1: &apos; + value),</span><br><span class="line">    err=&gt;console.log(&apos;observer 1 on error: &apos; + err)</span><br><span class="line">);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    tick$.subscribe(</span><br><span class="line">        value=&gt;console.log(&apos;observer 2: &apos; + value),</span><br><span class="line">        err=&gt;console.log(&apos;observer 2 on: error: &apos; + err)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line">//console</span><br><span class="line">//observer 1: 0</span><br><span class="line">//observer 1: 1</span><br><span class="line">//observer 1: 2</span><br><span class="line">//observer 1: done</span><br><span class="line">//observer 2: done</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li><p>publish完全是通过multicast来实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function(selector)&#123;</span><br><span class="line">    if(selector)&#123;</span><br><span class="line">        return this.multicast(()=&gt;new Subject(),selector);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return this.multicast(new Subject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>shared完全是通过multicast来实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.shared = function shared() &#123;</span><br><span class="line">    return this.multicast(() =&gt; new Subject()).refCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>除了以上这几个基础的多播操作符外，RxJS还支持三个高级多播操作符：</p>
<ul>
<li>publishList</li>
<li>publishReplay</li>
<li>publishBehavior<br>关于它们的使用可以自行查阅官网</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>《深入浅出RxJS》这本书较为系统的介绍了RxJS的核心特性和各类操作符，并且书该书结合弹珠图，将代码例子形象生动地描述清楚，给读者提供了很好的入门教程。个人觉得从书中前三章中得到的收获最大，从中了解到RxJS的代码架构、函数式编程的理念和如何实现操作符。后面介绍操作符用途的章节略显冗长，不过其中有些代码的例子特别贴切和生动，让人有眼前一亮的快感。可以看出作者对RxJS各类操作符的了解是非常深刻的。<br>  例如，讲解RxJS的高阶observable，所谓高阶，指的是该Observable返回的依旧是Observable，这样能够管理多个数据流，将管理数据和管理数据流归一化，类似于高阶函数，高阶函数的参数或者返回值是一个函数。这时就需要一些操作符能够组合或者处理这些高阶Observable，将其“砸平”，常见的有合并类高阶操作符concatAll，mergeAll，以及高阶的map等。<br>为了说明高阶map运算符concatMap的用途，作者列举了实现网页拖拽的例子。网页应用中，拖拽就是用户的鼠标在某个dom元素上按下去，然后拖动这个元素，最后松开鼠标的过程，这个过程是重复的，拖拽涉及的事件包括<br>mousedown，mouseup和mousemove，使用传统方式，基本上就是当mousedown事件发生时，用一个变量标识当前进入拖拽状态，然后监听mousemove事件，移动dom元素位置，当mouseup事件发生时，改变状态变量使之标记为“离开拖拽”，等待下一次mousedown事件的发生。<br>这个过程可以看成是多个由mousedown事件引发的数据流序列，每个序列内部又是以mouseup结束的mousemove数据序列。这些序列相互之间不可能交叉重复，这时可以考虑使用高阶map操作符concatMap实现这个例子。详细的代码可参考<a href="https://github.com/mocheng/dissecting-rxjs/blob/master/chapter-08/transform/src/concatMap/drag_drop.html" target="_blank" rel="noopener">concatMap example</a><br>  RxJS还有一些非常有意思的特性，包括Scheduler，单元测试等，这些并未在这篇博客中体现，读者可以根据自身需要去了解。<br>  可以得出，只有在项目中使用RxJS，经过大量实践，才能真正掌握RxJS这套工具。我乖乖地合上了这本书，打算找个项目练练手去了。</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>《深入浅出RxJS》这本书的代码依赖的是RxJs v5.5.0之前的版本，大部分操作符都是采用给Observable类打补丁的形式引用的，我在尝试看这本书的时候，RxJS的版本已经是V6.3.3了，在该版本中，将打补丁的形式完全移除，将所有实例操作符改成了pipeable操作符，其目录存放在”rxjs/operators”，静态操作符直接使用，其目录就在”rxjs/index.js”。</p>

        </div>
        
          


  <section class="meta" id="footer-meta">
    <hr>
    <div class="new-meta-box">
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-06-15T19:09:28+08:00">
  <a class="notlink">
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>最后更新于 Jun 15, 2019</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/blog/tags/函数式编程/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>函数式编程</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/blog/tags/响应式/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>响应式</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer" href="http://connect.qq.com/widget/shareqq/index.html?url=https://rhliu228.github.io./RxJS/&title=深入浅出RxJS总结 | Zoe的博客&summary=很早就在一些博客和书籍上了解到，javascript是一门具备函数式编程特性的语言，虽然在日常工作也会接触到js的闭包，函数绑定，函数柯里化等概念，但对于函数式编程的特点和优势，一直一知半解。加之在工作中总会遇到异步处理的糟糕代码，所以前段时间花了一些功夫在阅读程墨著作的《深入浅出RxJS》上。总的来说，RxJS是Reactive Extension(也叫ReactiveX)编程理念的javascript版本。Reactive Extension是实践响应式编程的一套工具，其诞生的主要目的是解决异步处理的问题，但这并不表示Rx不适合同步的数据处理。这篇文章主要总结自己阅读《深入浅出RxJS》的一些思考，关于RxJS的具体使用可参考ReactiveX。">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://rhliu228.github.io./RxJS/&title=深入浅出RxJS总结 | Zoe的博客&summary=很早就在一些博客和书籍上了解到，javascript是一门具备函数式编程特性的语言，虽然在日常工作也会接触到js的闭包，函数绑定，函数柯里化等概念，但对于函数式编程的特点和优势，一直一知半解。加之在工作中总会遇到异步处理的糟糕代码，所以前段时间花了一些功夫在阅读程墨著作的《深入浅出RxJS》上。总的来说，RxJS是Reactive Extension(也叫ReactiveX)编程理念的javascript版本。Reactive Extension是实践响应式编程的一套工具，其诞生的主要目的是解决异步处理的问题，但这并不表示Rx不适合同步的数据处理。这篇文章主要总结自己阅读《深入浅出RxJS》的一些思考，关于RxJS的具体使用可参考ReactiveX。">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer" href="http://service.weibo.com/share/share.php?url=https://rhliu228.github.io./RxJS/&title=深入浅出RxJS总结 | Zoe的博客&summary=很早就在一些博客和书籍上了解到，javascript是一门具备函数式编程特性的语言，虽然在日常工作也会接触到js的闭包，函数绑定，函数柯里化等概念，但对于函数式编程的特点和优势，一直一知半解。加之在工作中总会遇到异步处理的糟糕代码，所以前段时间花了一些功夫在阅读程墨著作的《深入浅出RxJS》上。总的来说，RxJS是Reactive Extension(也叫ReactiveX)编程理念的javascript版本。Reactive Extension是实践响应式编程的一套工具，其诞生的主要目的是解决异步处理的问题，但这并不表示Rx不适合同步的数据处理。这篇文章主要总结自己阅读《深入浅出RxJS》的一些思考，关于RxJS的具体使用可参考ReactiveX。">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
            <div class="prev-next">
                
                    <section class="prev">
                        <span class="art-item-left">
                            <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页</h6>
                            <h4>
                                <a href="/NumberInJs/" rel="prev" title="深入理解Javascript中的数字">
                                  
                                      深入理解Javascript中的数字
                                  
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/blog/tags/Javascript/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>Javascript</a>
                                </h6>
                            
                        </span>
                    </section>
                
                
            </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: '深入浅出RxJS总结',
      tools: true
    }
  </script>


</div>
<aside class="l_side">
  
    
    
      
        
          
          
            <section class="widget author">
  <div class="content pure">
    
      <div class="avatar">
        <img class="avatar" src="https://cdn.jsdelivr.net/gh/rhliu228/assets@master/avator/avator.jpg">
      </div>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:me@liurunhua.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

          
        
      
        
          
          
            
  <section class="widget toc-wrapper">
    
<header class="pure">
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;本文目录</div>
  
    <div class="wrapper"><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div>
  
</header>

    <div class="content pure">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数响应式编程"><span class="toc-text">函数响应式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数式编程"><span class="toc-text">函数式编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应式编程"><span class="toc-text">响应式编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Observable-和Observer"><span class="toc-text">Observable 和Observer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作符"><span class="toc-text">操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#操作符分类"><span class="toc-text">操作符分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#功能分类"><span class="toc-text">功能分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态和实例分类"><span class="toc-text">静态和实例分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作符的实现"><span class="toc-text">操作符的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#操作符函数实现"><span class="toc-text">操作符函数实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#操作符关联Observable"><span class="toc-text">操作符关联Observable</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#改进的操作符定义"><span class="toc-text">改进的操作符定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#操作符和Observable关联的缺陷"><span class="toc-text">操作符和Observable关联的缺陷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用call来创建库"><span class="toc-text">使用call来创建库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lettable和pipeable操作符"><span class="toc-text">lettable和pipeable操作符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多播"><span class="toc-text">多播</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hot和Cold数据流的差异"><span class="toc-text">Hot和Cold数据流的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Subject"><span class="toc-text">Subject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用Subject实现多播"><span class="toc-text">用Subject实现多播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#支持多播的操作符"><span class="toc-text">支持多播的操作符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#版本"><span class="toc-text">版本</span></a></li></ol>
    </div>
  </section>


          
        
      
        
          
          
            <section class="widget grid">
  
<header class="pure">
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class="content pure">
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/" href="/" id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="/blog/archives/" href="/blog/archives/" rel="nofollow" id="blogarchives">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            

          
        
      
        
          
          
            
  <section class="widget tagcloud">
    
<header class="pure">
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn" rel="nofollow" href="/blog/tags/" title="blog/tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class="content pure">
      <a href="/blog/tags/Javascript/" style="font-size: 24px; color: #555">Javascript</a> <a href="/blog/tags/Node/" style="font-size: 14px; color: #999">Node</a> <a href="/blog/tags/Performance/" style="font-size: 14px; color: #999">Performance</a> <a href="/blog/tags/babel/" style="font-size: 14px; color: #999">babel</a> <a href="/blog/tags/vue-cli3/" style="font-size: 14px; color: #999">vue-cli3</a> <a href="/blog/tags/webpack/" style="font-size: 14px; color: #999">webpack</a> <a href="/blog/tags/函数式编程/" style="font-size: 14px; color: #999">函数式编程</a> <a href="/blog/tags/响应式/" style="font-size: 14px; color: #999">响应式</a> <a href="/blog/tags/字符编码/" style="font-size: 19px; color: #777">字符编码</a>
    </div>
  </section>


          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="mailto:me@liurunhua.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Zoe的博客</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
</footer>
<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>




  
  
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        if ('.cover') {
          $('.cover').backstretch(
          ["https://img.vim-cn.com/6d/a0c9e6f9efad8b731cb7376504bd10d79d2053.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        } else {
          $.backstretch(
          ["https://img.vim-cn.com/6d/a0c9e6f9efad8b731cb7376504bd10d79d2053.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        }
      });
    </script>
  











  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  <script>setLoadingBarProgress(100);</script>
</body>
</html>
