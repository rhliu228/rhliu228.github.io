将值从一种类型转换为另一种类型叫做类型转换（type casting），这是显示的情况；隐式的情况称为强制类型转换（coercion）。也可以说，类型转换发生在静态类型语言的编辑阶段，强制类型转换发生在动态类型语言的运行时。
**JS的强制类型转换只会返回基本类型值，不会返回对象和函数**。可以从转换操作是否明显来划分显示强制类型转换和隐式强制类型转换。
#### 1.1 ToString
基本类型的字符串化规则为： null转化为"null"，undefined转化为"undefined"，true转化为"true"，false转化为"false"，数字的字符串化采用通用规则，不过极小和极大的数字使用指数形式。

对于对象来说，字符串化的背后规则是： 
1. 调用对象自身的toString方法，如果返回基本类型值，就直接对该值使用String函数，不再进行后续步骤。
2. 如果toString方法返回的是对象，再调用原对象的valueOf方法，如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行后续步骤。
3. 如果valueOf方法返回的是对象，则报错。

对于普通对象来说，除非自行定义，否则toString()返回内部属性[[Class]]的值，例如"[object Object]","[object RegExp]"。数组的默认toString方法经过了重新定义，将所有单元格字符串化后用","串联起来。

#### 1.2 ToNumber
将基本类型转换为数字的规则是： true转化为1，false为0。undefined转化为NaN，null转化为0。ToNumber对字符串的处理遵循数字常量的相关规则和语法。对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型，再遵循以上规则将其强制转换为数字。为了将值转换为基本类型值：
1. 抽象操作ToPrmitive会首先检查该值是否有valueOf()方法，如果有并且返回基本类型值，就使用该返回值进行强制类型转换。
2. 如果没有就继续使用toString()方法返回的基本类型值进行强制类型转换。
3. 如果valueOf和toString方法均不返回基本类型值，则产生TypeError错误。

例子： 
```
Number([]);  //0
Number("");  //0
Number([1]);  //1
Number([1,2]);  //NaN
Number(['abc']); //NaN
```
#### 1.3 ToBoolean
Javasccript中的值可以分为两类：
* 可以被强制转换为false的值
* 其他（被强制转换为true）的值

以下是假值： 
* undefined
* null
* false
* +0, -0, NaN
* ""

除此之外，浏览器在某些特定情况下，在常规Javascript语法基础上自己创建了一些外来值，这些就是假值对象。假值对象看起来和普通对象差不多，但将它们强制转换为布尔值时结果为false。例如IE浏览器在新版本中为了摆脱对旧版本对象document.all的支持，将其设置为假值对象。
#### 1.4 隐式强制类型转换
显示强制转换主要指使用Number、parseInt、String和Boolean等函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。当然是否是显式，取决于个人的理解和经验。例如var a = +c; 如果你已经知道一元运算符+会将操作数显示强制转换为数字，那它就是显式的。
隐式类型转换则主要是因为各种运算符对操作数的数据类型是有要求的，遇到非预期的数据类型时，会尝试自动转换数值的数据类型，这时就会出现隐式类型转换。
##### 1.4.1 转换为字符串
如果某个操作数是字符串或者通过与**ToNumber**抽象操作一样的处理对象方式能转换成字符串，则+号执行字符拼接操作。例如：
```
var a = [1,2];
var b = [3,4];
a + b;  //'1,23,4'
```
因为数组的valueOf方法返回数组自身，无法得到基本类型值，于是转而调用toString，上例中的数组变成了"1,2"和"3,4"，+号将它们拼接后返回"1,23,4"。
有一个坑常被提到，即[] + {} 和{} + []，它们分别返回"[object Object]" 和0。原因在于第二个表达式的第一个操作数{}被当作了一个空的代码块，单独执行+[]进行的是强制将[]转换为数字的操作，结果会是0。
a+""和String(a)有一个细微的区别，如果a是对象，a+""会首先尝试调用a的valueOf方法，获取基本值失败后再调用toString方法。但是String(a)与之相反。
