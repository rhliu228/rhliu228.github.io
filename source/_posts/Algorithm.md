---
title: 排序算法总结
date: 2019-07-05 14:00:00
tags: 
- Algorithm
---
本文对常见的排序算法和它们的空间、时间复杂度进行总结
<!-- more -->


| 排序算法 |平均时间复杂度 | 最好时间复杂度 |  最坏时间复杂度 | 空间复杂度 | 稳定性 |
| :------|:------| :------: | :------|:------| :------: |
| 插入排序 | O(n^2) | O(n^2) | O(n^2) | O(1) | Yes|
| 冒泡排序 | O(n^2) | O(n^2) | O(n^2) | O(1) | Yes|
| 选择排序 | O(n^2) | O(n) | O(n^2) | O(1) | No |
| 希尔排序 | O(n^1.5) | O(n^1.5) | O(n^2) | O(1) | No |
| 归并排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(n) | Yes |
| 堆排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(1) | No |
| 快速排序 | O(nlogn) | O(nlogn) | O(n^2)  | O(logn) | No |
| 计数排序 | O(n+m) | O(n+m) | O(n+m)  | O(n+m) | Yes |
| 桶排序   | O(n) | O(n) | O(n)  | O(m) | Yes |
| 计数排序 | O(n*k) | O(n*k) | O(n^2)  | ? | Yes |

其中k代表数值中“数字”的个数，n代表数据规模，m代表数据的最大值减去最小值

#### 1. 插入排序
插入排序将数组分为有序和无序两部分，每次从无序部分取出一个数字，将其与前面已经排好序的子序列进行比较，并插到有序子序列中的正确位置。
```
const insertSort = arr => {
    for(let i = 1; i< arr.length; i++) {
        let temp = arr[i];
        for(let j = i; j > 0 && temp < arr[j-1]; j--) {
            arr[j] = arr[j-1];
        }
        arr[j] = temp;
    } 
    return arr;
}
```

#### 2. 冒泡排序
冒泡排序包括一个简单的双重for循环。第一次内部for循环从记录数组的底部比较到顶部，比较相邻的关键码。如果低序号的关键码比高序号的关键码大，就交换两者的顺序。一旦遇到一个最小的关键码值，这个过程使它像“气泡”一样被推到数组的顶部。第二次再重复调用上面的过程，但是，既然知道最小元素在第一次就被推到了数组的最上面，因此就没有再比较最上面两个元素的必要了。同理，每轮循环都比上一轮循环少比较一个关键码。

```
const bubbleSort = arr => {
    for(let i = 0; i < arr.length-1; i++) {
        for(let j = arr.length-1; j>i; j--) {
            if(arr[j] < arr [j-1]){
                [arr[j], arr[j-1]] = [arr[j-1], arr[j]];
            }
        }
    }
    return arr;
}
```