{"meta":{"title":"Zoe的博客","subtitle":null,"description":null,"author":"Liu.Runhua","url":"https://rhliu228.github.io.","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-06-15T12:38:03.646Z","updated":"2019-06-15T12:38:03.645Z","comments":true,"path":"404.html","permalink":"https://rhliu228.github.io./404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"},{"title":"","date":"2019-06-15T12:46:34.095Z","updated":"2019-06-15T12:46:34.095Z","comments":true,"path":"friends/index.html","permalink":"https://rhliu228.github.io./friends/index.html","excerpt":"","text":""},{"title":"好好学习，天天向上","date":"2019-08-04T13:34:41.217Z","updated":"2019-08-04T13:34:41.217Z","comments":true,"path":"about/index.html","permalink":"https://rhliu228.github.io./about/index.html","excerpt":"","text":""},{"title":"","date":"2019-06-15T12:47:21.371Z","updated":"2019-06-15T12:47:21.370Z","comments":true,"path":"projects/index.html","permalink":"https://rhliu228.github.io./projects/index.html","excerpt":"","text":""},{"title":"","date":"2019-06-15T14:56:11.203Z","updated":"2019-06-15T14:56:11.203Z","comments":true,"path":"blog/archives/index.html","permalink":"https://rhliu228.github.io./blog/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-06-15T12:43:45.294Z","updated":"2019-06-15T12:43:45.291Z","comments":true,"path":"blog/categories/index.html","permalink":"https://rhliu228.github.io./blog/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-06-15T12:41:59.278Z","updated":"2019-06-15T12:41:59.278Z","comments":true,"path":"blog/tags/index.html","permalink":"https://rhliu228.github.io./blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"第一次社招面试总结（下）","slug":"Interview2","date":"2019-11-27T09:04:00.000Z","updated":"2019-11-27T14:13:38.074Z","comments":true,"path":"Interview2/","link":"","permalink":"https://rhliu228.github.io./Interview2/","excerpt":"背景经历了八、九月份的面试后，我觉得不能吊死在鹅厂上，于是把目光投向了字节跳动。在师弟的怂恿下，我刷起了算法，主要途径就是阅读《剑指offer》和刷leetcode。国庆前后，我先后投了微信、字节跳动、大疆。","text":"背景经历了八、九月份的面试后，我觉得不能吊死在鹅厂上，于是把目光投向了字节跳动。在师弟的怂恿下，我刷起了算法，主要途径就是阅读《剑指offer》和刷leetcode。国庆前后，我先后投了微信、字节跳动、大疆。 大疆找师兄要内推码，投了简历之后，很快就收到了测评邮件。测评问题不难，涉及性格、智力、数学等方面，不过题量有点大。大疆的面试比较灵活，一面基本上围绕项目展开，二面面试官喜欢问一些智力题和证明题，脑筋急转弯不过关的我就掉进了那一堆硬币、三角形的陷阱里，然后挂了。一面有两个面试官，一上来就丢给我一个问题：请说一说你的项目，阐述它的难点。我开始滔滔不绝地阐述，其中有一个树形结构的可视化展示需求，引起了面试官的注意，所以很不幸，面试方向转为探讨K叉树的树构造、节点查询所花费的时间、空间复杂度。。。最后，采用数据结构map，通过空间换取时间的策略，我赢得了进入二面的机会。二面面试官喜欢考察候选人是否具有发散思维，基础是否扎实不重要，关键是脑洞要够大。有些问题记不清了，这里写下还记得的。 有两组数据：A1,A2,B1,C1,C2,D1,D2,D3…A,B,C,D…要求转变成：A1,A2,A,B1,B,C1,C2,C,D1,D2,D3,D…请写出代码这道题有很多解法，面试官对一些约束条件也没具体说明，只能靠自己设想并询问清楚。但是有一点让我意外的是，面试官看不懂我代码里的es6语法。。。 12345for(var i = 0; i &lt; 5; i++) &#123; setTimout(function()&#123; console.log(i); &#125;,0);&#125; 问怎么修改才能让控制台依次打印出0、1、2、3、4。 我一下子就说了三种方法： 将var改成let 使用闭包 利用setTimeout的第三个参数： 12345for(var i = 0; i &lt; 5; i++) &#123; setTimout(function(j)&#123; console.log(j); &#125;, 0, i);&#125; 说完之后，才意识到自己掉进陷阱里了，后面再也想不出其他方法了。。。 有一段代码： 12345var X = 10;function X() &#123; X = 1; console.log(X);&#125; 问这段代码打印什么结果；如何修改代码，让代码分别打印1和10。我首先说了我的理解，告诉面试官函数声明提升优先级高于普通变量声明，但是面试官貌似不知道这个原则，我只能呵呵。 有21个硬币，其中10个正面，蒙住你的眼睛，问如何将硬币分成两份，每份正面朝上的硬币数目一样。 有一个直角三角形，斜边长10cm，斜边上的高为6cm，求三角形面积。这道题其实是想让候选人想到，这个三角形其实是不存在的。 面完之后，我就已经觉得凉凉了。这次面试完全没有发挥自己的优势，面试官说创新是与生俱来的，大疆更喜欢脑子灵动的人。我虽然有点难受，但不得不说，大疆不适合我，挂了我也罢。 微信鹅厂一年工作经验的岗位太少了，所以我思来想去，斗胆投了微信。微信在正式面试之前给我发了一道题目：实现一个随机选座系统。我主要采用动态规划的思想，花了一番功夫写出了核心代码，然后就收到了一面邀约。 项目经历中涉及云计算，所以面试官让我聊一聊SaaS，Iaas，Paas 说一说JS原型链，手写代码实现JS继承。我采用的继承方式是寄生组合式继承，具体可参考红宝书。 用过哪些es6新特性，promise，generator如何实现。promise需要注意的是如何实现链式调用，而generator本质上就是一个状态机。 map，set对比，map和对象有什么区别 let const区别 请详细说说你知道的web安全和对应的防御方式。我主要讲述了XSS，CSRF，点击劫持，跨域安全等。 token如何实现，token一定要存放在服务端吗。其实token不一定放在服务端，也可以放在cookie中，取出来作对比即可。但是如果网站同时存在XSS漏洞，那token有可能发生泄漏。 cookie和session有什么区别 session一般存放在什么地方 浏览器缓存级别 200和304有什么区别 babel-preset-env如何配置构建两次 webpack和rollup对比，webpack如何实现一个插件，webpack如何管理插件 vue如何实现数据绑定，vue更新视图采用的是同步还是异步。 react setstate异步还是同步，事务机制。这里的事务机制没有理解透彻，所以回答得不好。 算法题：一个表里存储着数据，每一行包括用户的姓名，出生日期，死亡日期，求哪一年人口总数最多 平时如何学习前端 一面与面试官聊的挺好的，可惜那个部门没有hc了，所以把我转推给了微信的另一个部门。有点惨的地方在于，又得重新做题。。题目如下： for循环+setimeout输出结果 考察原型链继承 vue filter实现一个trim 每当用户调用console.log方法时，需要在输出的内容后追加一个字符串“type”。这里其实就是想让我重写console.log。 实现一个控制并发请求的函数，正在执行ajax请求的最大数目是m，所有请求完成后输出所有响应结果。 求二叉树任意两个节点之间的距离 实现JSON.stringify 问答环节主要涉及： 讲解试卷 vue和react区别 nodejs原理 HTTPS原理 写过什么静态类型的语言；c++从文本变成可执行程序经过哪些步骤。这里我居然漏了汇编环节。。事实上，c++文件需要经过预编译、编译、汇编、链接才可变成可执行程序。 做过哪些性能优化 微信总监面让人觉得压力太大，而且比较喜欢挖掘项目。 说一说你的项目难点。我参与的项目并没有多难，所以面试官老是反问我，这里有什么难的吗。。。 实现一个淘宝的商品规格联动置灰高亮功能。 双向链表能否转换成二叉搜索树，为什么。 为什么JS事件会存在事件代理。 在不支持position:fixed的浏览器中如何模拟实现这个效果。 什么是ACID。 为什么跳槽。 事实上，项目难点确实是我的硬伤，所以我又一次挂了鹅厂。 字节跳动首先，字节跳动的算法并没有想象得这么难。其次，四面都是视频面试，省去了来回奔波的烦恼，很赞。一面： promise、setTimeout执行顺序 实现一个函数add，要求如下：add(1,2)(3).sumOf(); // 6add(1,2,3).sumOf(); // 6add(1)(2)(3)(4).sumOf(); //10add(1)(2,3)(4)(5).sumOf(); //15…… 实现一个函数print，奇数次调用打印1，偶数次调用打印2，不允许使用全局变量 实现一个函数，用于执行二进制字符串相加：eg: ‘110001’ + ‘110100’ = ‘1100101’ 问答： 牛客网里，你在牛客网提供的编辑器写代码，为什么我这边能实时看见。 二面： 使用Array的reduce方法实现map方法 实现es6的Symbol:var s1 = Symbol(‘s’);var s2 = Symbol(‘s’);s1 === s2; // falsevar s3 = Symbol.for(‘s’);var s4 = Symbol.for(‘s’);s3 === s4; // true 两个无序数组，合并成一个有序数组，如果两个数组存在交集，则取数量多的那一侧。eg: 数组1: [3,2,2,1] 数组2: [2,2,2,4] 合并后的结果: [1,2,2,2,3,4] 给定一个数字字符串和变换次数k，判断是否能否在该变换次数k之内，将该数字字符串变成回文字符串，且数字尽可能大。 问答：挑一个你们项目依赖的插件或者框架，说一说它的特点。我挑了axios，然后面试官问我如何实现axios的拦截器功能。 三面： 给一串数字，给它加上千位分隔符 http常见状态码有哪些，403代表什么意思，有哪些应用场景，304呢？ expires、cache-control、etag、last-modified的优先级，为什么。 etag是怎么实现的 csrf成因和防御措施 项目难点 为什么离职 个人优缺点 总结最后拿到了字节跳动的offer，于是就跑路了。总的来说，面试确实不是一件容易的事，需要实力、技巧和持久的毅力。而且就算准备了很多，面试还得看眼缘和运气。嘤嘤嘤，最想去鹅厂了，可惜它不肯收我。最后感谢这一年来陪伴我的书籍：《深入浅出nodejs》《你不知道的Javascript》上中下卷《大型网站技术架构》《白帽子讲web安全》《Javascript设计模式与开发实践》《web性能权威指南》《剑指offer》","categories":[],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"https://rhliu228.github.io./blog/tags/前端开发/"}]},{"title":"第一次社招面试总结（上）","slug":"Interview","date":"2019-11-03T05:02:00.000Z","updated":"2019-11-27T09:04:43.677Z","comments":true,"path":"Interview/","link":"","permalink":"https://rhliu228.github.io./Interview/","excerpt":"背景去年七月毕业，在某中小厂从事前端开发工作，由于对所处公司的薪资和发展空间不满意，所以就有了跳槽的想法。从八月份面试到现在，一共面过四家公司： 腾讯、广发证券、大疆、字节跳动。特此总结与各位共勉。","text":"背景去年七月毕业，在某中小厂从事前端开发工作，由于对所处公司的薪资和发展空间不满意，所以就有了跳槽的想法。从八月份面试到现在，一共面过四家公司： 腾讯、广发证券、大疆、字节跳动。特此总结与各位共勉。 腾讯视频招聘要求写了两年以上经验，所以投简历时犹豫不决，后来很庆幸收到了HR的邀约电话。约了8月10号周六早上，面试地点是滨海大厦。由于第一次参加社招，有些问题没有总结得很到位，此次面试惨败。 vue3新特性。 记得尤大大在某次分享上做过一个全面的介绍，网上也有对应的ppt，但是很可惜我只记得一个特性: 用es6的proxy来进行数据劫持，所以就简单介绍了一下该特性。 在vue2.x中， 往数组里push一个元素，vue能不能监听到，为什么。 回答是可以，因为vue对数组的方法进行了重写。 项目页面数据是如何交互的。这个问题让我愣了一下，并不了解数据交互指的是哪些方面。我开始试图反问面试官，想从中获取更多的信息。但是很可惜，我列举的nodejs中间层， mongodb存储数据等都不是面试官想要的，只能作罢。 从输入URL到打开页面发生了什么事情。这个属于老生常谈的问题了，我滔滔不绝地说了一大通，也不知道面试官是否有走神，反正说完也没有追问细节。。。 说一说websocket协议。刚好看过《web性能权威指南》这本书，所以较为系统地介绍了websocket协议。但是由于缺乏实战，所以说起来磕磕绊绊，估计被面试官看出来了。 说一说你做过的性能优化。我把自己做过的查找js内存泄漏，利用浏览器缓存等问题大致说了一下。 做了一道关于js变量声明提升以及一道关于this指向的题目，但是一不小心混淆了普通变量声明和函数声明的一些细节，导致第一道题目做错了。。。。 一道智力题：一群聪明的人呆在一个房间，每人头上都戴着一顶帽子。帽子只有黑白两种，黑的至少有一顶。每个人都能看到其它人帽子的颜色，却看不到自己的。主持人先让大家看看别人头上戴的是什么帽子，然后关灯，如果有人认为自己戴的是黑帽子，就打自己一个耳光。第一次关灯，没有声音。于是再开灯，大家再看一遍，关灯时仍然鸦雀无声。一直到第三次关灯，才有打耳光的声音响起。问有多少人戴着黑帽子？这道题一开始一点思绪都没有，只能问面试官要提示，面试官估计也不赶时间，就慢慢引导我，最终勉强答上了吧。。 面完之后，面试官给我的建议是多点实践，比如websocket如何检测通讯中断和实现重连，websocket队首阻塞等问题都必须在实战中才能掌握。 面完当天下午就把我挂了~。 QQ浏览器挂了腾讯视频之后，我又投了QQ浏览器。由于有了一次失败的经历，这次面试，我显得更加从容淡定。面试时间选择在一个平静的周四晚上，吃过晚饭之后，我来到了万利达大厦。一个长得很温文儒雅的小哥接待了我，“很有气质的面试官，眼睛会笑”，我心里暗想。然鹅，他从简历下面拿出来一份试卷，告诉我做完到旁边的工位喊他一下。。不过很庆幸，那份试卷做下来难度不大： load和domcontentLoaded事件对比 描述两种跨域方法 实现一个shallowEqual函数，比较两个对象是否浅层相等 用nodejs实现在一个4G内存中复制一个16G大文件 一道有意思的原型链问题 描述nodejs这种事件驱动单线程模式与PHP多线程阻塞模式对比的优缺点 做完题目之后，面试官开始看我写的答案和简历，进入提问环节。 说说DOM事件流。这里涉及事件捕获、处于目标阶段、事件冒泡三个阶段。 react diff算法复杂度以及背后原理。 react中给组件加key的作用。 redux里面的reducer为什么是一个纯函数。这里涉及到与pure render相结合进行性能优化。 我用pipe实现nodejs的大文件读取，所以面试官问我管道pipe背后的实现原理。我回答了Buffer。面试官追问4G内存装不下16G文件咋办，文件系统是如何处理读写速度不匹配问题的。我突然想到这是典型的生产者消费者问题，所以大致介绍了一下该模型以及涉及到的死锁、信号量问题等。 浏览器如何渲染一个页面。我回答了构建DOM树、构建render树、layout、paint等阶段，以及其中涉及到的渲染线程、合成器线程、栅格线程等线程的协作。面试官接着追问我浏览器如何提升图层。 描述一下HTTPS，越详细越好。这个是必备考点，通过阅读《web性能权威指南》和《码农翻身》，拿下这道题自然不在话下。 服务端渲染如何实现，优点是什么。回答需要解决前后端路由统一问题、区分环境处理数据获取问题等，优点当然是加速首屏渲染，利于SEO优化等 nodejs的异步IO是如何实现的。回答利用多线程+阻塞IO。 除了javascript，你还会什么语言。 一面后，等了一会儿，盼来了微胖的二面小哥。 说说你负责的项目。 项目如何做到定制化，按需打包。 在不考虑首次渲染的情况下，ssr和csr对比。这里其实想问的是csr带来的缓存好处是否能够媲美ssr的直出渲染 script标签有什么属性。defer和async区别。 说说对项目做过的性能优化。 说一说项目中做过的最让自己自豪的一个功能。 承接上一问，假如有上万个好友节点需要插入页面，怎么优化。 nodejs如何共享多个node进程间的缓存共享问题。回答是利用redis等。 面完二面后，三面面试官没空，所以先让我回去了。过了几天，接到了三面面试官的邀约电话。三面仍然是现场面试。不过当我看到面试官拿出被他揉得皱巴巴的简历时，我惊呆了。。 为什么跳槽。 对前端岗位怎么理解。 项目难度和项目分工。 项目如何设计权限管理，画一画流程图吧。 项目使用http还是https，加密算法有了解哪些。 是否了解过websocket协议；如何用http模拟websocket 后端如何存储海量数据（亿级）。这里应该回答用分布式数据库的。。。 redis有哪些数据结构。我只记得hash和set，面试官接着追问我它们的背后实现方法，我回答hash使用数组+链表。其他更高级的例如跳跃表、红黑树啥的我都不太了解。。。 前端未来的发展趋势。 四面应该是总监面，只需要电话面试即可。 vue和react有什么不同 xss漏洞原理以及如何防御；有哪些字符需要转义 cookie有哪些过期方式 在项目中如何做性能优化；你还知道哪些性能优化 nodejs有哪些应用场景 你为什么想要离职 四面完成后，等了一周，被告知备胎了，再过一周，依然无消息，只能放弃了。总结一下，自己参与的项目确实没多大亮点，而且觉得该部门希望候选人能多一点后端相关的项目经历，只能继续努力了。 QQ音乐qq音乐貌似急着招人，所以一二面都是电话面试。一面安排在晚上九点多，真是辛苦面试官了。 项目中遇到的问题和难点 tcp为什么刚开始很慢，后来越来越快。一开始我回答的是tcp三次握手，后来经过提醒，我才想到主要原因应该是tcp慢启动算法导致的。 跨域方式有哪些；jsonp有什么缺陷；jsonp如何捕获错误。要回答这个问题，首先要了解jsonp如何实现，我只知道jsonp主要缺点是只支持get请求，很难捕获错误。后来查阅资料才了解到，jsonp容易导致xss漏洞，超时设置貌似是解决jsonp错误捕获的一个常见方法。 csrf漏洞成因以及如何防御。 如何用两个栈实现一个队列。 如何做性能优化。 有没有做过nodejs相关的。 除了javascript还懂什么语言。 如何实现ssr。 为什么想要离职。 二面问的问题很多，偏向前端，面完之后对qq音乐的印象很好。 vue和react对比 vue是如何做到响应式更新的 介绍diff算法 react fiber实现原理；requestIdleCallback不兼容怎么办。 react生命周期 redux起到什么作用；redux middleware实现原理。 react hooks主要解决什么问题，背后实现原理是什么。 http相关：状态码204作用，有哪些应用场景；504、304代表什么；Etag和Last modified区别 local storage、session storage、cookie有哪些区别 react native与flutter对比 graphQL作用和实现原理 webassembly概念 如何垂直水平居中一个元素 rem和em区别 es6箭头函数特点，什么情景下应该使用箭头函数 es6解析赋值作用 如果一个页面性能不好，你会从哪些方面找原因 内存泄漏有哪些原因 贡献过哪些开源项目 有做过什么技术沉淀的工作，比如写博客等 面完二面后，被告知通过，但是无奈与qq浏览器面试流程冲突，而且当时qq浏览器已经面完4面，不想轻易放弃，只能中断qq音乐的面试。 广发证券广发证券的招聘信息是在一个公众号上看到的，投简历之后，很快有面试官联系，一个下午走完一二面，共耗时三小时。每轮面试有两个面试官，每个面试官都有自己的技术特长，问题广而杂，整体来说水平不错。面完之后，身心俱疲，很多问题想不起来了。 组件库开发与业务开发区别 rollup和webpack区别 什么叫tree shaking 说一说组件库项目的架构 commonjs模块和es模块的对比 for in vs for of 什么是CSRF,如何防御 详细说一下HTTPS 从输入URL到页面显示经过什么步骤，这些步骤中可以分别做出什么性能优化的措施 快速排序时间复杂度 DNS被污染了有什么应对措施 如何查看一个域名对应的请求IP地址 你觉得你有哪些技能没有被这次面试考察到。我回答我的JS基础还可以，然后面试官开始跟我聊chrome内核的实现。。。比如chrome中字符串有哪几种实现；为什么以前用字符串拼接很慢，现在反而不会，chrome做了什么优化；GC垃圾回收算法等。…… 过了两天，hr约我进行下一轮总监面。当时忙着面试鹅厂，而且感觉自己就算面过了也不会去，就放弃了。 后记第一阶段的面试到了九月中旬就结束了。本来以为最有希望的qq浏览器惨败，回头去询问qq音乐被告知已招满，所以最终结果是0offer。心灰意冷之际，我决定好好刷一刷算法题，准备国庆后二战。","categories":[],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"https://rhliu228.github.io./blog/tags/前端开发/"}]},{"title":"比较Node和浏览器的Event Loop","slug":"EventLoop","date":"2019-09-14T12:52:00.000Z","updated":"2019-09-15T04:23:34.428Z","comments":true,"path":"EventLoop/","link":"","permalink":"https://rhliu228.github.io./EventLoop/","excerpt":"一直以为大致搞懂浏览器的eventLoop就差不多了，直到我看了《Node.js调试指南》后，才发现把浏览器和Node环境的eventLoop混在一起谈是不合适的。虽然它们的任务源确实存在很大区别，但更重要的是，Node下eventloop的“读取任务队列”划分为6个阶段，从而导致两者在优先级队列的执行次序上有很大不同。 这篇文章主要阐述浏览器和node环境的eventloop异同。","text":"一直以为大致搞懂浏览器的eventLoop就差不多了，直到我看了《Node.js调试指南》后，才发现把浏览器和Node环境的eventLoop混在一起谈是不合适的。虽然它们的任务源确实存在很大区别，但更重要的是，Node下eventloop的“读取任务队列”划分为6个阶段，从而导致两者在优先级队列的执行次序上有很大不同。 这篇文章主要阐述浏览器和node环境的eventloop异同。JavaScript是单线程运行，所以异步操作特别重要。为了管理异步回调， Javascript采取事件循环（Event Loop）的策略： 所有任务都在主线程上运行，形成一个执行栈（Execution Context Stack） 在主线程之外还存在一个或者多个“任务队列”（Task Queue），系统把异步任务放到“任务队列”中。 一旦“执行栈”中的任务执行完毕，系统就会读取“任务队列”。某个异步任务结束等待状态，从“任务队列”进入执行栈，得以执行。 主线程不断重复第三步。 1. 浏览器与Event LoopHTML规范中对Event Loop的定义如下： To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops as described in this section. Each agent has an associated event loop. 同时规定： An event loop has one or more task queues. A task queue is a set of tasks.（一个event loop可以有1个或多个task queue）。 Per its source field, each task is defined as coming from a specific task source. For each event loop, every task source must be associated with a specific task queue.（每个task定义时都有一个task source，从同一个task source来的task必须放到同一个task queue，从不同源来的则被添加到不同的task queue）。 Tasks encapsulate algorithms that are responsible for such work as: Events,Parsing,Callbacks,Using a resource,Reacting to DOM manipulation,etc. 每个(task source对应的)task queue都保证自己队列的先进先出的执行顺序，但event loop的每个turn，是由浏览器决定从哪个task source挑选task。这允许浏览器为不同的task source设置不同的优先级，比如为用户交互设置更高优先级来使用户感觉流畅。 1.1 macrotask规范里提及的task又称macrotask，从webappapis.html#generic-task-sources可以看出，task源包括： DOM 操作任务源：如元素以非阻塞方式插入文档 用户交互任务源：如鼠标键盘事件。用户输入事件（如 click） 必须使用 task 队列 网络任务源：如 XHR 回调 history 回溯任务源：使用 history.back() 或者类似 API 此外 setTimeout、setInterval、IndexDB 数据库操作等也是任务源。总结来说，常见的 task 任务有： 事件回调 XHR 回调 IndexDB 数据库操作等 I/O setTimeout / setInterval history.back 1.2 microtask从webappapis.html#microtask可以知道，每一个 eventloop 都有一个 microtask 队列。microtask 会放在 microtask 队列而非 task 队列中。一般来说，microtask 包括： Promise.then MutationObserver Object.observe 1.3 Processing model规范webappapis.html#event-loop-processing-model描述了eventloop的处理过程，简述为以下步骤： 从 task 队列（一个或多个）中选出最老的一个 task，执行它。 执行 microtask 检查点（checkpoint），执行microtask队列中的所有 microtask，直到队列为空。如果microtask又添加了新的 microtask，直接放进本队列末尾。 执行UI render（可选）。 首先判断document在此时间点渲染是否会“获益”。浏览器只需保证 60Hz 的刷新率即可（在机器负荷重时还会降低刷新率），若eventloop频率过高，即使渲染了浏览器也无法及时展示。所以并不是每轮 eventloop 都会执行 UI Render。 执行各种渲染所需工作，如 触发 resize、scroll 事件、建立媒体查询、运行 CSS 动画等等 执行animation frame callbacks 执行IntersectionObserver callback 渲染 UI promise A+规范里规定promise不能返回自己，因为promise.then会把回调注册到本次microtask队列中，从而导致第二步中的microtask队列永远不可能为空，造成死循环。 1.4 microtask 的执行时机 观察以下代码： 123456789setTimeout(() =&gt; &#123; console.log(&apos;A&apos;)&#125;, 0)requestAnimationFrame(() =&gt; &#123; console.log(&apos;B&apos;) Promise.resolve().then(() =&gt; &#123; console.log(&apos;C&apos;) &#125;)&#125;) 打印结果为：”B C A”或者”A B C”（B，C一定紧挨着输出）。从中可以知道，requestAnimationFrame 中注册的 microtask 并没有在下一轮 eventloop 的 task 之后执行，而是直接在本轮 eventloop 中紧跟着 requestAnimationFrame 执行了。也就是说一轮 eventloop 中有可能执行多次 microtask 2. Node与Event Loop Node官网对Event Loop的描述如下： The event loop is what allows Node.js to perform non-blocking I/O operations — despite the fact that JavaScript is single-threaded — by offloading operations to the system kernel whenever possible. Node.js采用V8作为js的解析引擎，而I/O处理方面使用了libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它的内部实现。 Event Loop的“读取任务队列”有6个阶段（phase）： 123456789101112131415161718 ┌───────────────────────────┐┌─&gt;│ timers ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ pending callbacks ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ idle, prepare ││ └─────────────┬─────────────┘ ┌───────────────┐│ ┌─────────────┴─────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └─────────────┬─────────────┘ │ data, etc. ││ ┌─────────────┴─────────────┐ └───────────────┘│ │ check ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐└──┤ close callbacks │ └───────────────────────────┘ event loop 的每个phase都有一个FIFO任务队列 当 event loop 到达某个phase时，将执行该阶段的任务队列，直到队列清空或执行的回调达到系统上限后，才会转入下一个阶段 当所有phase被顺序执行一次后，称 event loop 完成了一个 tick 每个phase的作用如下： timers： 执行setTimeout()和setInterval()中到期的callback pending callbacks：上一轮循环中有少数的I/O callbacks会被延迟到这一轮的这一阶段执行 idle，prepare：仅内部使用 poll：执行I/O callback，在适当的条件下，node会阻塞在这个阶段 check：执行setImmediate()的callback close callbacks：执行close事件的callback，例如socket.on(‘close’, func) 2.1 poll阶段poll阶段主要有两个功能，如下所述。 当timers的定时器到期后，执行定时器（setTimeout和setInterval）的callback 执行poll队列里的I/O callback 如果Event Loop进入了poll阶段，且代码未设定timer，则可能发生以下情况。 如果poll queue不为空，则event loop将同步queue里的callback，直至queue为空，或者执行的callback达到系统上限 如果poll queue为空，则可能发生以下情况： 如果代码用setImmediate()设定了callback，则event loop将结束poll阶段并进入check阶段，执行check阶段的queue 如果代码没有使用setImmediate()，则event loop将阻塞在这个阶段，等待callback进入poll queue，如果有callback进来则立即执行 一旦poll queue为空，则Event Loop将检查timers，如果有timers的时间到期，则Event Loop将回到timers阶段，然后执行timer queue 2.2 process.nextTick()process.nextTick()不在Event Loop的任何阶段执行，而是在各个阶段切换的中间执行，即从一个阶段切换到下一个阶段前执行。node把macroTask定义为在每个阶段执行的任务，而microtask则是指在每个阶段之间执行的任务。即上述6个阶段都是macrotask，而process.nextTick属于microtask。12345678910const promise = Promise.resolve();promise.then(() =&gt; &#123; console.log(&apos;promise&apos;);&#125;);process.nextTick(() =&gt; &#123; console.log(&apos;nextTick&apos;);&#125;);// nextTick// promise 二者优先级不一样，process.nextTick的microtask queue总是优先于promise的microtask执行。 3. Node.js 与浏览器的 Event Loop 差异浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。 在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，才会去执行microtask队列的任务。 4. 实例观察以下代码：123456789101112131415161718192021222324252627setTimeout(()=&gt;&#123; console.log(&apos;timer1&apos;) Promise.resolve().then(function() &#123; console.log(&apos;promise1&apos;) &#125;)&#125;, 0)setTimeout(()=&gt;&#123; console.log(&apos;timer2&apos;) Promise.resolve().then(function() &#123; console.log(&apos;promise2&apos;) &#125;)&#125;, 0)//浏览器输出timer1promise1timer2promise2// node输出（node版本v8.11）timer1timer2promise1promise2 在浏览中，两个timer被当作两个macrotask，所以先输出timer1, promise1，再输出timer2，promise2。在node环境下，timer1和timer2都处于timers阶段，首先执行timer1的回调函数，并将promise1.then放入microtask队列，此时队列仍不为空，接着执行timer2，将promise2.then放入microtask队列。timers阶段结束后，执行microtask队列的所有回调，打印promise1，promise2。（node11之后，node为了保持和浏览器的一致，一次只执行一个timers回调） 参考： 深入探究 eventloop 与浏览器渲染的时序问题 event-loop The Node.js Event Loop, Timers, and process.nextTick() promise A+","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://rhliu228.github.io./blog/tags/Javascript/"},{"name":"Node","slug":"Node","permalink":"https://rhliu228.github.io./blog/tags/Node/"}]},{"title":"利用Chrome开发者工具探讨运行时性能","slug":"Performance","date":"2019-08-01T06:57:35.000Z","updated":"2019-08-05T13:06:58.946Z","comments":true,"path":"Performance/","link":"","permalink":"https://rhliu228.github.io./Performance/","excerpt":"RAIL模型是一个以用户为中心的性能模型，讲述每个网络应用都会在Response, Animation, Idle, Load四个方面影响用户体验。本文主要讲述如何使用Chrome和DevTools查找影响页面性能的内存问题，包括内存泄漏、内存膨胀和频繁的垃圾回收。","text":"RAIL模型是一个以用户为中心的性能模型，讲述每个网络应用都会在Response, Animation, Idle, Load四个方面影响用户体验。本文主要讲述如何使用Chrome和DevTools查找影响页面性能的内存问题，包括内存泄漏、内存膨胀和频繁的垃圾回收。 内存泄漏： 页面随着时间的延长越来越卡顿，这是因为页面中的错误导致页面随着时间的延长使用的内存越来越多 内存膨胀： 内存膨胀是指页面为达到最佳速度而使用的内存比本应使用的内存多，这时页面的性能会一直很糟糕 频繁垃圾回收： 垃圾回收是指浏览器收回内存，这是由浏览器决定的。当页面出现延迟或者经常暂停时，说明存在频繁垃圾回收，因为回收期间，所有脚本执行都将暂停 以下将从几个方面展开讨论： Chrome Performance工具 解决性能问题 其他工具 一. Chrome Performance平时我们使用chrome开发者工具，用的比较多的工具是Element、Source、Network等，而今天的主角Performance的关注点是运行时性能表现（runtime performance）。Performance面板主要包括四个部分： Controls: 开始记录，停止记录和配置记录期间捕获的信息 Overview: 页面性能概览 Main Section主体: 可以查看火焰图，Network活动 Details: 选择事件后，此窗格会显示与该事件有关的更多信息。 未选择事件时，此窗格会显示选定时间范围的相关信息。 Figure1: performance面板 1.1 ControlsFigure2: Controls 1.1.1 记录运行时性能(Record)按下此按钮，会对当前页面的运行记录进行记录，在记录的过程中，该按钮显示红色。 1.1.2 记录加载性能(Load)按下后会自动重新加载当前页面并在数秒后停止录制。在生成的火焰图可以看到不同颜色的垂直虚线。蓝线代表DOMContentLoaded事件，绿线代表首次绘制的时间，红线代表load事件。其中First Paint标示浏览器渲染任何视觉上不同于导航前屏幕内容的时间点，First Contentful Paint表示从输入URL进行导航到浏览器开始渲染DOM第一个字节的时间点，First Meaningful Paint表示页面主要内容出现在屏幕的时间，主要内容的定义因页面而异，对于博客来说，它是标题+首评文本，对于搜索引擎，它可能是搜索结果。Figure3: 加载性能 1.1.3 清除按钮(Clear)按下后会清除之前的记录信息，恢复白板状态 1.1.4 录制截屏(Screenshots)在录制过程中启动截屏，此功能开启后会有一定性能消耗。开启后会在NET下方生成每一帧的截屏 1.1.5 查看内存指标(Memory)：开启后会在Details面板上方显示一张新的Memory图表，并在NET图标下方显示HEAP图表，HEAP图表与Memory图表的JS HEAP曲线展示的均是JS堆内存的占用状况，此外Memory图表还记录了Node节点数、监听函数数目和GPU占用等信息。 1.1.6 垃圾回收(GC)记录过程中点击后会强制浏览器进行GC垃圾回收活动 1.1.7 捕获设置(Capture)移动设备的CPU和网络一般比PC端更弱。分析页面时，可以用该组设置模拟移动端设备糟糕的CPU和网速等。 Disable Javascript Samples默认情况下，火焰图(见下方)会显示JS函数调用的所有堆栈细节，可以通过启用该选项来禁止这一默认行为。启用选项后，火焰图只会显示JS顶部函数的调用堆栈 Throttle the network while recording模拟移动端的网络状态，默认情况下为No throttling Throttle the CPU while recording模拟移动端的CPU架构，默认情况下为No throttling Enable advanced paint instrumentation启用该选项后可以查看浏览器的视图层和详细绘制信息 1.2 OverviewFigure4: Overview 1.2.1 FPS（刷新率）表示一秒之间能够完成多少次重新渲染网页，一次重新渲染代表一帧（frame）。一般的网页动画，需要达到每秒30帧到60帧的频率，才能比较流畅。每秒低于24帧的动画，人眼就能感受到停顿；而如果能达到每秒70帧甚至80帧，就会极其流畅。大多数显示器的刷新频率是60Hz，为了与系统一致，以及节省电力，浏览器会自动按照这个频率，与显示器同步刷新（如果可以做到的话），达到最佳的视觉效果。根据公式T=1/f，可以得知，每次重新渲染的时间间隔不能超过16.66毫秒，也就是说JavaScript每个任务的耗时，必须少于16毫秒。下图的绿色竖线越高，FPS 越高。 FPS 图表上的红色块表示FPS很低，很可能存在性能问题。 1.2.2 CPU此面积图指示消耗CPU资源的事件类型： 蓝色：网络通信和HTML解析 黄色：JavaScript执行 紫色：样式计算和布局，即布局 绿色：绘制 1.2.3 NET每个蓝色横杆表示一次网络请求，横杆越长，代表该次请求花费时间越长。 1.2.4 HEAP内存图标视图，显示堆内存占用状态。随着内存使用量的增长，你会看到图表区域的时间线捕获也会增长。 当图表突然下降时，代表一次垃圾收集器（Garbage collector）运行时的实例，此时清理了引用的内存对象。 1.3 Main Section1.3.1 Flame Graph火焰图火焰图最初用于展示linux系统CPU调用栈，其y轴表示调用栈，每一层都是一个函数；x 轴表示抽样数，如果一个函数在x轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。浏览器的火焰图与标准火焰图有两点差异： 它是倒置的（即调用栈最顶端的函数在最下方） x轴是时间轴，而不是抽样次数。 Figure5: Flame Chart 上图显示各种事件的信息大集合，上层代表随着时间推移而发生的事件，下面各行是上层事件的子项，由下面的各项组成上层的整体事件。标注有红色三角形方块的事件表示该事件存在性能问题。条的高度与调用堆栈的深度相对应，高调用堆栈只是表示调用了大量的函数。但宽条表示调用表明需要很长时间完成，而这需要优化。 1.3.2 Network网络资源请求瀑布图，以不同颜色的条状表示不同的资源 黄色：script文件 蓝色：html文件 紫色： css文件 绿色： 媒体文件 灰色： 各种其他文件。 Figure6: Network waterfall 可以点击某个请求条后在Details面板查看该请求的详细信息。左上角存在深蓝色方块的请求代表这是一个高优先级的请求，意味着这是一个关键渲染路径上的请求；反之，一个浅蓝色标识的请求意味着低优先级。 在上图中，对搜狗翻译的html页面请求由三个部分组成： 左侧的实线+中间的长块+右侧的实线。 左侧实线标示Request Sent前的准备时间 右侧实线标示该请求等待主线程的时间 而多色长块前面的浅色部分代表TTFB（Time To First Byte）（从最初网络请求到从服务器接收到第一个字节的花费时间），深色部分表示资源下载时间（Content Download）。 点击 Chrome Network面板，可以在Timing tab找到对应的请求信息： Figure7: Network Timeing 1.3.3 Frames这是对Overview面板FPS的详细说明，鼠标移到每个帧的色柱上方，会显示该帧耗时和对应的FPS。左右移动鼠标，可以重现当时的屏幕录像。这被称为scrubbing, 可以用来分析动画的各个细节。点击某一帧，可以在Details面板查看该帧的详细信息。 Figure8: Frame 1.3.4 Memory在Controls点击Memory Checkbox后，会在Details面板上方生成内存时间线（Memory Timeline）， 这里可以看到内存使用按JS堆（与Overview窗格中的HEAP图表相同）、文档、DOM 节点、侦听器和GPU内存细分。Figure9: Memory Timeline 1.4 DetailsDetails面板根据用户所选返回范围和事件类型显示对应的具体信息。 Summary：所选事件的一个信息汇总 Figure10: Summary Tab Bottom-Up tab：如果要查看哪些活动占据了大部分时间，应使用Bottom-Up tab。该面板根据事件耗时长短，反向列出事件，不过也支持自定义排序和依据分类过滤。 Figure11: Bottom-Up Tab 其中，Self Time表示该事件在所选范围内直接耗费的总时间，不包括任何子事件；Total Time表示在该事件或其任何子事件中花费的总时间。 Call Tree tab：当你想查看哪些根活动引起的事件占据了大部分时间，应使用Call Tree tab。根活动是指那些引起浏览器做某些工作的活动。 Figure12: Call Tree tab Event Log tab：按照事件在录制过程中的触发顺序一一列举 Figure13: Event Log tab 下表是一些常见事件属性说明 事件 说明 Parse HTML Chrome 执行其 HTML 解析算法。 XHR Ready State Change XMLHTTPRequest 的就绪状态已发生变化 Timer Fired 使用 setInterval() 或 setTimeout() 创建的定时器已被触发。 Function Call 已调用一个函数 Recalculate style Chrome 重新计算了元素样式 GC Event 发生垃圾回收 DOMContentLoaded 浏览器触发DOMContentLoaded事件。当页面的所有 DOM 内容都已加载和解析时，将触发此事件 更多事件说明可参考Timeline Event Reference 1.5 其他浏览器除了负责网络请求工作和执行脚本以外，当用户在浏览器输入一个网页后，浏览器还会在背后做很多工作。 Figure14: WebKit main flow 利用performance工具，可以在浏览器中查看关于浏览器布局和绘制的各个活动的详细信息。 1.5.1 查看layers 在controls的capture中勾选Enable advanced paint instrumentation checbox 点击绘制并生成图表 在Frame面板中选择某一帧，这时可以看到在Details面板中多了一个新的Tab：Layers。 Figure15: layer 1.5.2 paint profiler 在controls的capture中勾选Enable advanced paint instrumentation checbox 点击绘制并生成图表 在火焰图中点击选择一个paint事件，这时可以看到在Details面板中多了一个新的Tab：Paint Profiler。 Figure16: paint profiler 1.5.3 render和layout 打开Command Menu, 输入Rendering，调出Rendering面板 选中Paint Flashing checkbox 二. 解决性能问题2.1 Chrome 任务管理器实时监视内存使用 Chrome 主菜单并选择 More tools &gt; Task manager，打开任务管理器 右键点击任务管理器的表格标题并启用JavaScript memory Figure17: Task Manager Memory 列表示原生内存(native memory)，DOM节点存储在原生内存中。 如果此值正在增大，则说明正在创建DOM节点。 JavaScript Memory列表示JS堆。此列包含两个值。实时数字表示页面上的可到达对象正在使用的内存量。如果此数字在增大，要么是正在创建新对象，要么是现有对象正在增长。 渲染器内存（Renderer memory）是渲染页面的进程的内存总和：原生内存 + 页面的JS堆内存 + 页面启动的所有web worker的JS堆内存。原生对象是JavaScript堆之外的任何对象，存放于原生内存中。 2.2 使用Memory Timeline可视化内存泄漏Figure18: Memory Timeline如果JS堆大小或节点大小不断增大，则可能存在内存泄漏。 2.3 使用Heap snapshot查看DOM外引用的内存泄露Heap snapshot可以按页面的JavaScript对象和相关DOM节点显示内存分配。快照有三种视图，可以从不同角度查看快照。 打开Chrome Memory面板，点击Heap snapshot 点击Take snapshsot，等待生成快照 2.3.1 summary可以显示按构造函数名称分组的对象。Figure19: Memory summary 表格标题的字段含义分别是： Constructor 表示使用此构造函数创建的所有对象，后面跟着对象实例数。 Shallow Size列显示通过特定构造函数创建的所有对象浅层大小的总和。浅层大小是指对象自身占用的内存大小。 Retained Size 列显示同一组对象中最大的保留大小。将对象本身连同其无法从GC根到达的相关对象一起删除后释放的内存大小，称为保留大小(Retained Size)。 Distance 显示该节点距根节点的最短路径距离。 2.3.2 Containment视图采用自顶向下的方式显示对象的结构Figure20: Memory Containment 2.3.3 Statistics视图按照数据类型划分内存的使用Figure21: Memory Statistics 2.3.4 Memory Summary视图跟踪DOM泄漏。只有页面的DOM树或JavaScript码不再引用DOM节点时，DOM节点才会被作为垃圾进行回收。如果某个节点已从DOM树移除，但某些JavaScript仍然引用它，我们称此节点为“detached”。已分离的DOM节点是内存泄漏的常见原因。可以使用Heap snapsho找出已分离的DOM节点并移除它们。 切换到Summary视图 在搜索框里输入Detached，过滤出Detached Dom节点 Figure22: Heap snapshot 2.4 使用Allocation timeline查看JS堆内存泄露 打开Chrome Memory面板，点击Allocation instrumentation on timeline 点击Start，等待生成快照 执行怀疑存在内存泄漏的部分，然后点击Stop Figure23: Allocation timeline Allocation timeline显示新分配的堆内存并标示对应的保留路径（retaining path）。每个条形的高度对应于最近分配的对象的大小，条形的颜色指示这些对象是否仍然存在于最终堆快照中。 蓝色条表示在录制结束时仍然存在内存的对象，灰色条表示在录制期间分配的堆对象，但此后已被垃圾收集。若一个蓝色条在录制结束后没有按照期望的那样被GC收集，可以拖动时间轴的滑块定位到特定的时间范围，并在下方查看对象的保留路径来查看为什么没有被GC回收。 2.5 使用Allocation Sampling查看分配给函数的内存 打开Chrome Memory面板，点击Allocation Sampling 点击Start，与页面交互 点击Stop，等待生成Profiler Figure24: Allocation Sampling 2.6 使用Javascript Profiler识别CPU开销大的函数使用CPU分析器准确地记录调用了哪些函数和每个函数花费的时间： 打开Chrome Javascript Profiler面板，点击Record Javascript CPU Proile 点击Start，与页面交互 点击Stop，等待生成Profiler 默认会生成火焰图： Figure25: Javascript Profiler1 点击Heavy (Bottom Up)，将按照函数对性能的影响列出函数，可以检查函数的调用路径： Figure26: Javascript Profiler2 2.7 发现频繁的垃圾回收如果感觉页面经常暂停，则可能存在垃圾回收问题。JavaScript的内存模型建立在称为垃圾收集器的技术之上。在许多语言中，程序员直接负责从内存的堆中分配和释放内存。但是，垃圾收集器系统代表程序员管理此任务，这意味着当程序员解除引用时，对象不会直接从内存中释放，而是将决定权交给GC。GC需要对活动和非活动对象执行一些统计分析，这需要一段时间来执行，回收期间，所有脚本执行都将暂停。除此之外，系统本身决定何时运行GC，程序员无法控制此操作，在代码执行期间的任何时候都可能发生GC回收活动。经常创建/释放对象的过程称为“memory churn”，因为这意味着程序不得不经常阻塞以等待GC回收完成。应避免以下情形出现： Figure27: Bad GC 可以通过performance overview面板的HEAP或者Memory Timeline来观察GC的活动，JS堆大小频繁上升和下降指示存在频繁的垃圾回收，这时页面会存在卡顿现象。 三. 更多 可以使用Chrome的Audit面板来测试和分析网站，测试完毕后LightHouse会给出性能评估和优化建议 使用Performance API来监控系统性能并进行数据上报分析 参考： Static Memory Javascript with Object Pools Fix Memory Problems 如何读懂火焰图？ Performance Analysis Reference How to Record Heap Snapshots Navigation Timing Level 2","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://rhliu228.github.io./blog/tags/Javascript/"},{"name":"Performance","slug":"Performance","permalink":"https://rhliu228.github.io./blog/tags/Performance/"}]},{"title":"如何用Javascript对字符进行UTF8编解码","slug":"UTF8_Javascript","date":"2019-07-15T07:00:00.000Z","updated":"2019-08-04T13:26:58.037Z","comments":true,"path":"UTF8_Javascript/","link":"","permalink":"https://rhliu228.github.io./UTF8_Javascript/","excerpt":"前段时间，接到一个字节校验的需求，要求我校验某个字段的长度，用户输入的数据转变为UTF8字符后，其字节长度不得超过1024。我立马想到，javascript内部字符以UTF-16的格式存储，要转化成UTF-8字符，需要找到合适的转化函数。通过查阅资料，发现其实这个问题并没有想象得这么复杂，还突然认识了URL编码函数的强大，所以特写下这篇文章，记录一下解决这个问题的思路。","text":"前段时间，接到一个字节校验的需求，要求我校验某个字段的长度，用户输入的数据转变为UTF8字符后，其字节长度不得超过1024。我立马想到，javascript内部字符以UTF-16的格式存储，要转化成UTF-8字符，需要找到合适的转化函数。通过查阅资料，发现其实这个问题并没有想象得这么复杂，还突然认识了URL编码函数的强大，所以特写下这篇文章，记录一下解决这个问题的思路。一开始，找到的方法是这样子的：12345678910111213141516171819202122232425262728293031323334var utf16ToUtf8 = function (utf16Str) &#123; var utf8Arr = []; var byteSize = 0; for (var i = 0; i &lt; utf16Str.length; i++) &#123; //获取字符Unicode码值 var code = utf16Str.charCodeAt(i); //如果码值是1个字节的范围，则直接写入 if (code &gt;= 0x00 &amp;&amp; code &lt;= 0x7f) &#123; byteSize += 1; utf8Arr.push(code); //如果码值是2个字节以上的范围，则按规则进行填充补码转换 &#125; else if (code &gt;= 0x80 &amp;&amp; code &lt;= 0x7ff) &#123; byteSize += 2; utf8Arr.push((192 | (31 &amp; (code &gt;&gt; 6)))); utf8Arr.push((128 | (63 &amp; code))) &#125; else if ((code &gt;= 0x800 &amp;&amp; code &lt;= 0xd7ff) || (code &gt;= 0xe000 &amp;&amp; code &lt;= 0xffff)) &#123; byteSize += 3; utf8Arr.push((224 | (15 &amp; (code &gt;&gt; 12)))); utf8Arr.push((128 | (63 &amp; (code &gt;&gt; 6)))); utf8Arr.push((128 | (63 &amp; code))) &#125; else if(code &gt;= 0x10000 &amp;&amp; code &lt;= 0x10ffff )&#123; byteSize += 4; utf8Arr.push((240 | (7 &amp; (code &gt;&gt; 18)))); utf8Arr.push((128 | (63 &amp; (code &gt;&gt; 12)))); utf8Arr.push((128 | (63 &amp; (code &gt;&gt; 6)))); utf8Arr.push((128 | (63 &amp; code))) &#125; &#125; return utf8Arr &#125; 这个方法的关键是通过charCodeAt()获取每个字符对应的码点，然后判断码点的范围，将对应的字节大小和长度存放到数组中。但是试验后发现，这个方法无法识别和处理码点大于0xffff的字符。后来我想到encodeURIComponent就是对参数进行UTF-8编码的，能不能借助这个方法干点什么。随后，在网上找到了以下方法：1234567891011121314151617181920212223242526272829//从utf-16字符串转换成utf-8字节数组 function utf8_from_str(s) &#123; for(var i=0, enc = encodeURIComponent(s), a = []; i &lt; enc.length;) &#123; if(enc[i] === &apos;%&apos;) &#123; a.push(parseInt(enc.substr(i+1, 2), 16)) i += 3 &#125; else &#123; a.push(enc.charCodeAt(i++)) &#125; &#125; return a&#125;//从utf-8字节数组转换成utf-16字符function utf8_to_str(a) &#123; for(var i=0, s=&apos;&apos;; i&lt;a.length; i++) &#123; var h = a[i].toString(16) if(h.length &lt; 2) h = &apos;0&apos; + h s += &apos;%&apos; + h &#125; return decodeURIComponent(s)&#125;// or//从utf-8字节数组转换成utf-16字符function uintToString(uintArray) &#123; var encodedString = String.fromCharCode.apply(null, uintArray); var decodedString = decodeURIComponent(escape(encodedString)); return decodedString;&#125; encodeURIComponent和decodeURIComponent会对参数进行UTF-8编码，但是这两个都是百分号编码，会在编码后的字节前面加上%，所以处理的时候需要充分利用好这个%。不过观察上述最后一个函数： 1var decodedString = decodeURIComponent(escape(encodedString)); 居然用到了不推荐使用的escape函数，真是一脸懵。查阅资料后发现，对于非ASCII字符的Unicode字符，escape的编码方式是%uxxxx，其中的xxxx是用来表示unicode字符的4位十六进制字符。这种方式已经被W3C废弃了。但是在ECMA-262标准中仍然保留着escape的这种编码语法。encodeURI和encodeURIComponent则使用UTF-8对非ASCII字符进行编码，然后再进行百分号编码，这是RFC推荐的。上面语句中的encodedString是一串字符乱码，使用escape()方法对其编码，由于其不能识别utf-8字节，只会在每个字节前加上百分号。然后再采用decodeURIComponent解码，就可以得到正确的utf-16字符了。如果只需要在utf-16字符和utf-8字符之间简单转换，网友给出了更简洁的解法：1234567function encode_utf8(s) &#123; return unescape(encodeURIComponent(s));&#125;function decode_utf8(s) &#123; return decodeURIComponent(escape(s));&#125; 最后，贴上字符和ArrayBuffer数组之间的转换：12345678910111213// 字符串转为ArrayBuffer对象，借助ArrayBuffer对象的byteLength可以获取字节长度const str2ab = function(str) &#123; var buf = new ArrayBuffer(str.length * 2); // 每个字符占用2个字节 var bufView = new Uint16Array(buf); for (var i = 0, strLen = str.length; i &lt; strLen; i++) &#123; bufView[i] = str.charCodeAt(i); &#125; return buf;&#125;// ArrayBuffer转为字符串const ab2strU16 = function (buf) &#123; return String.fromCharCode.apply(null, new Uint16Array(buf));&#125; 参考Decode UTF-8 with Javascript","categories":[],"tags":[{"name":"字符编码","slug":"字符编码","permalink":"https://rhliu228.github.io./blog/tags/字符编码/"},{"name":"Javascript","slug":"Javascript","permalink":"https://rhliu228.github.io./blog/tags/Javascript/"}]},{"title":"JS的强制类型转换","slug":"TypeCasting","date":"2019-06-28T06:00:00.000Z","updated":"2019-07-22T13:19:54.247Z","comments":true,"path":"TypeCasting/","link":"","permalink":"https://rhliu228.github.io./TypeCasting/","excerpt":"本文是我在看了《你不知道的Javascript（中卷）》后对Javascript的强制类型转换的归纳和总结。看完书中的第一部分后，对强制类型转换和宽松相等、严格相等有了更透彻的理解。","text":"本文是我在看了《你不知道的Javascript（中卷）》后对Javascript的强制类型转换的归纳和总结。看完书中的第一部分后，对强制类型转换和宽松相等、严格相等有了更透彻的理解。将值从一种类型转换为另一种类型叫做类型转换（type casting），这是显示的情况；隐式的情况称为强制类型转换（coercion）。也可以说，类型转换发生在静态类型语言的编辑阶段，强制类型转换发生在动态类型语言的运行时。JS的强制类型转换只会返回基本类型值，不会返回对象和函数。可以从转换操作是否明显来划分显示强制类型转换和隐式强制类型转换。 1.1 ToString基本类型的字符串化规则为： null转化为”null”，undefined转化为”undefined”，true转化为”true”，false转化为”false”，数字的字符串化采用通用规则，不过极小和极大的数字使用指数形式。 对于对象来说，字符串化的背后规则是： 调用对象自身的toString方法，如果返回基本类型值，就直接对该值使用String函数，不再进行后续步骤。 如果toString方法返回的是对象，再调用原对象的valueOf方法，如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行后续步骤。 如果valueOf方法返回的是对象，则报错。 对于普通对象来说，除非自行定义，否则toString()返回内部属性[[Class]]的值，例如”[object Object]”,”[object RegExp]”。数组的默认toString方法经过了重新定义，将所有单元格字符串化后用”,”串联起来。 1.2 ToNumber将基本类型转换为数字的规则是： true转化为1，false为0。undefined转化为NaN，null转化为0。ToNumber对字符串的处理遵循数字常量的相关规则和语法。对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型，再遵循以上规则将其强制转换为数字。为了将值转换为基本类型值： 抽象操作ToPrmitive会首先检查该值是否有valueOf()方法，如果有并且返回基本类型值，就使用该返回值进行强制类型转换。 如果没有就继续使用toString()方法返回的基本类型值进行强制类型转换。 如果valueOf和toString方法均不返回基本类型值，则产生TypeError错误。 例子：12345Number([]); //0Number(&quot;&quot;); //0Number([1]); //1Number([1,2]); //NaNNumber([&apos;abc&apos;]); //NaN 1.3 ToBooleanJavascript中的值可以分为两类： 可以被强制转换为false的值 其他（被强制转换为true）的值 以下是假值： undefined null false +0, -0, NaN “” 除此之外，浏览器在某些特定情况下，在常规Javascript语法基础上自己创建了一些外来值，这些就是假值对象。假值对象看起来和普通对象差不多，但将它们强制转换为布尔值时结果为false。例如IE浏览器在新版本中为了摆脱对旧版本对象document.all的支持，将其设置为假值对象。 1.4 隐式强制类型转换显示强制转换主要指使用Number、parseInt、String和Boolean等函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。当然是否是显式，取决于个人的理解和经验。例如var a = +c; 如果你已经知道一元运算符+会将操作数显示强制转换为数字，那它就是显式的。隐式类型转换则主要是因为各种运算符对操作数的数据类型是有要求的，遇到非预期的数据类型时，会尝试自动转换数值的数据类型，这时就会出现隐式类型转换。 1.4.1 转换为字符串如果某个操作数是字符串或者通过与ToNumber抽象操作一样的处理对象方式能转换成字符串，则+号执行字符拼接操作。例如：123var a = [1,2];var b = [3,4];a + b; //&apos;1,23,4&apos; 因为数组的valueOf方法返回数组自身，无法得到基本类型值，于是转而调用toString，上例中的数组变成了”1,2”和”3,4”，+号将它们拼接后返回”1,23,4”。有一个坑常被提到，即[] + {} 和{} + []，它们分别返回”[object Object]” 和0。原因在于第二个表达式的第一个操作数{}被当作了一个空的代码块，单独执行+[]进行的是强制将[]转换为数字的操作，结果会是0。a+””和String(a)有一个细微的区别，如果a是对象，a+””会首先尝试调用a的valueOf方法，获取基本值失败后再调用toString方法。但是String(a)与之相反。 1.4.2 转换为数字除了加法运算符（+）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。 1.4.3 转换为布尔值下面情况会发生布尔值的隐式强制类型转换： if语句 for(…;…;…)中的条件判断语句 while，do while ? : 中的条件判断表达式 || &amp;&amp; 左边的操作数 这里为什么指明|| 、&amp;&amp;左边的操作数而不是整个语句呢？因为和其他语言不同，在Javascript中该整个表达式返回的并不是布尔值，它的返回值是两个操作数中的一个（且仅一个）：1234567var a = 42;var b = &quot;abc&quot;;var c = null; a||b; // 42 a&amp;&amp;b; // &quot;abc&quot; c||b; // &quot;abc&quot; c&amp;&amp;b; // null 所以与其它们为逻辑运算符，倒不如称它们为“选择器运算符”。 1.5 宽松相等和严格相等宽松相等==和严格相等===的区别在于： ==允许在相等比较中进行强制类型转换，===不允许。ES5规范的抽象相等比较算法定义了==运算符的行为。 1.5.1 有两个点需要时刻牢记： NaN不等于NaN +0等于-0 两个对象的宽松相等，仅当它们指向同一个值时视为相等。 1.5.2 字符串和数字之间的比较 如果Type(x)是数字，Type(y)是字符串，则返回x === ToNumber(y)的结果。 如果Type(x)是字符串，Type(y)是数字，则返回ToNumber(x) === y的结果。 1.5.3 其他类型和布尔类型之间的相等比较 如果Type(x)是布尔类型，则返回ToNumber(x) === y的结果。 如果Type(y)是布尔类型，则返回x === ToNumber(y)的结果。 123var x = true;var y = &apos;42&apos;;x == y; // false Type(y)是布尔值，首先将其转换为数字1，变成1 == ‘42’,二者类型不等，’42’根据1.5.2规则被转换为42，变成1==42，结果为false。由此可以看出，字符串’42’既不等于true也不等于false。 1.5.4 null和undefined的相等比较 如果x为null，y为undefined，返回true。 如果x为undefined，y为null，返回true。 除此之外其他值都不会和它们两个相等 1.5.4 对象和非对象的相等比较 如果Type(x)是数字或字符串，Type(y)是对象，则返回x === ToPrimitive(y)的结果。 如果Type(x)是对象，Type(y)是数字或字符串，则返回ToPrimitive(x) === y的结果。 1.5.5假值比较12345678&quot;0&quot; == false // truefalse == 0 // truefalse == [] // truefalse == &#123;&#125; // false&quot;&quot; == 0 // true&quot;&quot; == [] //true0 == [] // true... 还有一种极端的情况1[] == ![] // true 上述表达式会首先进行布尔值的强制类型转换，所以[] == ![]变成了[] == false,由于[] == false，所以结果为true 1.5.6总结 如果两边的值中有true或者false，千万不要用==。 如果两边有[]，””或者0，尽量不要用==。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://rhliu228.github.io./blog/tags/Javascript/"}]},{"title":"JS的类型和特殊值","slug":"Type_Value","date":"2019-06-22T01:01:00.000Z","updated":"2019-07-22T13:21:13.172Z","comments":true,"path":"Type_Value/","link":"","permalink":"https://rhliu228.github.io./Type_Value/","excerpt":"大多数开发者认为，像Javascript这样的动态语言是没有类型的，但是事实上，ECMAScript语言中所有的值都有一个对应的语言类型，ECMAScript语言类型包括：Undefined、null、Boolean、String、Object、Number、symbol。Javascript中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。","text":"大多数开发者认为，像Javascript这样的动态语言是没有类型的，但是事实上，ECMAScript语言中所有的值都有一个对应的语言类型，ECMAScript语言类型包括：Undefined、null、Boolean、String、Object、Number、symbol。Javascript中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。 1. undefined和undeclared已在作用域中声明但是还没有赋值的变量，是undefined的；相反，还没有在作用域中声明过的变量，是undeclared的。123var a;a; // undefinedb; // ReferenceError: b is not defined 这里 b is not defined 很容易让人以为是“b is undefined”,这里显示为为“b is not declared”会更准确。更让人抓狂的是typeof处理undeclared变量的方式：123var a;typeof a; // undefinedtypeof b; // undefined 对于undeclared的变量，typeof居然返回“undefined”。b虽然是一个undeclared的变量，但是typeof b并没有报错，这是因为typeof有一个特殊的安全防范机制。然而，typeof的安全机制对于在浏览器中运行的js代码来说还是很有用处的，例如：123456789// 这样会报错if(DEBUG)&#123; console.log(&apos;debug mode&apos;);&#125;// 这样是安全的if(typeof DEBUG !== &apos;undefined) &#123; console.log(&apos;debug mode&apos;);&#125; 还有要为某个缺失的功能编写polyfill：1234if(typeof atob === &apos;undefined&apos;) &#123; //这里没有用var声明变量 atob = function() &#123;/** */&#125;&#125; 如果在if语句里声明var atob，因为存在变量声明提升，该声明会被提升到作用域最顶层，即使if语句条件不成立也是如此（即浏览器本来就支持atob）。在某些浏览器中，对于特殊的内置全局变量（宿主对象），这样的重复声明会报错。还可以通过判断某个全局变量是否是全局对象的属性来避免undeclared变量的判断出错：123if(!window.atob) &#123;&#125; 与undeclared变量不同，访问不存在的对象属性不会产生Reference error。 2. 字符串JS中的字符串是不可变的，但是数组是可变的。字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串，而数组的成员函数都是在其原始值上进行操作。可以借用数组的非变异函数来处理字符串：12345var a = &apos;foo&apos;;var c = Array.prototype.join.call(a,&quot;-&quot;); //f-o-ovar d = Array.prototype.map.call(a,function(v)&#123; return v.toUpperCase() + &quot;.&quot;;&#125;); //&quot;F.O.O.&quot; 但是无法借用数组的变异函数来处理字符串，例如reverse，push等。为了实现字符串反转，可以：1var c = a.split(&quot;&quot;).reverse().join(&quot;&quot;); JS的数组变异函数包括： push() pop() shift() unshift() splice() sort() reverse() 3. undefined和nullundefined类型只有一个值，即undefined，null类型也只有一个值，即null；它们的名称既是类型也是值。它们之间有一些细微的区别： null指空值，undefined指没有值 undefined指从未赋值，null指曾经赋过值，但目前没有值 null是一个特殊关键字，不是标识符，不能被当作变量来使用和赋值，而undefined是一个标识符，可以被当作变量来使用和赋值。3.1 在非严格模式下，我们可以为全局标识符undefined赋值，1234undefined = 2; //ugly&quot;use strict&quot;;undefined = 2; //TypeError 3.2 在非严格和严格模式下，可以声明一个局部变量undefined：12var undefined = 2;console.log(undefined); //ugly 3.3 undefined是一个内置标识符，它的值为undefined，通过void运算符即可得到该值。12var a = 2;console.log(void a, a); //undefined 2 利用void运算符可以让表示式不返回任何结果，例如用于函数return语句中。1234function foo() &#123; //... return void setTimout(dosomething, 500);&#125; 4. NaNjs中有一个特殊的数字：NaN。NaN的含义是“Not a number”，如果数字运算的操作数不是数字，就无法返回一个有效的数字，这种情况下应该返回NaN。12var a = 2/&apos;foo&apos;; // NaNtypeof a === &apos;number&apos;; // true NaN是唯一一个非自反的值，即NaN !== NaN 为true。既然无法对NaN进行比较，那如何判断一个值是否是NaN呢?可以利用window对象内置的isNaN()方法。1isNaN(a); //true 但是这样方法有一个缺陷，它的检查方式是检查参数是否不是NaN，也不是数字。1234var a = 2/&apos;foo&apos;;var b = &apos;foo&apos;;window.isNaN(a); // truewindow.isNaN(b); // true 从ES6开始可以用Number.isNaN()检测，这个方法会避免上面的bug，其polyfill如下：123456789101112if(!Number.isNaN) &#123; Number.isNaN = function(n) &#123; return typeof n === &apos;number&apos; &amp;&amp; window.isNaN(n); &#125;&#125;//更简单的方法if(!Number.isNaN) &#123; Number.isNaN = function(n) &#123; return n!==n; &#125;&#125; 5. 零值Javascript中有一个常规的0（也叫做+0）和-0。-0除了可以用作常量之外，也可以是某些数学运算的返回值：12var a = 0 / -3; //-0var b = 0 * -3; //-0 加法和减法运算不会得到-0。有时候数学运算的符号位用来表示移动方向等信息。此时如果一个值为0的变量失去了它的符号位，它的方向信息就会丢失，这是-0存在的意义。根据规范，对负零进行字符串操作会返回“0”：12345678var a = 0 / -3;console.log(a); // &quot;-0&quot;//但是规范定义的返回结果是这样：a.toString(); //&quot;0&quot;a+&quot;&quot;; //&quot;0&quot;String(a); //&quot;0&quot;JSON.stringify(a); //&quot;0&quot; 此外， 0与-0进行===比较时会返回true，为了区分二者，需要做一些特殊处理：1234function isNegZero(n) &#123; n = Number(n); return (n===0) &amp;&amp; (1/n===-Infinity)&#125; 6. 特殊等式NaN和-0在相等比较时表现特殊，es6加入了Object.is()来判断两个值是否绝对相等，可以用来处理上述的特殊情况：12345678910111213if(!Object.is) &#123; Object.is = function(v1, v2) &#123; //判断是否是-0 if(v1===0 &amp;&amp; v2===0)&#123; return 1/v1 === 1/v2; &#125; //判断是否是NaN if(v1 !== v1) &#123; return v2 !== v2; &#125; return v1 === v2; &#125;&#125; 注意，能使用==和===就不要使用Object.is(),因为前者效率更高，更为通用。Object.is主要用来处理那些特殊的相等比较。 7. 值和引用在许多编程语言中，赋值和参数传递可以通过值复制或者引用复制的方法来完成，取决于使用的语法。但是在JS中，对值和引用的复制完全根据值的类型来决定，在语法上没有任何区别:简单值总是通过值复制的方式来赋值/传递；复合值总是通过引用复制的方式赋值或者传递。例如：在c语言中12345678910111213void swap(int &amp;x, int &amp;y) &#123; int temp; temp = x; x = y; y = temp;&#125;main() &#123; int a =1, b =2; swap(a,b); cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;&quot;b=&quot;&lt;&lt;b&lt;&lt;&quot;\\n&quot;; return 1;&#125;//输出 a=2 b=1 传引用调用实际上在形参位置插入的是变量本身，即值的内存位置。由于程序变量是作为内存位置来实现的，所以这些内存位置就是变量。引用相当于变量的别名，本身并不单独分配自己的内存空间，二者指向的是同一处内存。而在JS中：12345678910function foo(x) &#123; x.push(4); x; //[1,2,3,4] x = [4,5,6]; x.push(7); x; //[4,5,6,7]&#125;var a = [1,2,3];foo(a);a; //[1,2,3,4] 向函数传递a的时候，实际是将引用a的复本赋值给x，刚开始x和a指向的是同一处内存，所以x.push(4)改变的是同一个值。随后x不再指向数组[1,2,3,4],而是指向新分配的内存[4,5,6]。因为数组是复合值，所以这里默认采用引用赋值，不需要特殊的语法。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://rhliu228.github.io./blog/tags/Javascript/"}]},{"title":"webpack构建 ES2015+ module","slug":"ES6Module","date":"2019-06-20T06:00:00.000Z","updated":"2019-07-22T13:35:43.764Z","comments":true,"path":"ES6Module/","link":"","permalink":"https://rhliu228.github.io./ES6Module/","excerpt":"webpack与babel7结合，可以构建出更符合实际需求的ES2015+ module，本文从vue-cli3入手，讲述CLI工具如何结合babel、webpack等开发插件动态支持用户编译到ES2015+ ，提升代码运行效率","text":"webpack与babel7结合，可以构建出更符合实际需求的ES2015+ module，本文从vue-cli3入手，讲述CLI工具如何结合babel、webpack等开发插件动态支持用户编译到ES2015+ ，提升代码运行效率用vue CLI3搭建项目，发现该工具减少了现代前端工具在配置上的烦恼，且其基于webpack 4的预配置提供构建设置，尽可能地在工具链中加入当前和未来的最佳实践。通过vue-cli3构建项目时，它会安装Vue CLI运行时命令（vue-cli-service），选择功能插件，生成必要的配置文件，然后就可以愉快地专注于业务代码了。而且该CLI工具尊重各个第三方工具的配置文件，如果我们对这些依赖进行配置，可以很轻松地更改配置文件或者通过webpack-merge合并到最终的配置中。 当我第一次使用vue-cli3的时候，只是赞叹于它漂亮的GUI界面，并不了解vue-cli3在背后集成了什么配置。它在package.json的script入口提供了分别用于开发模式和生产模式的两个命令，当然我还采用了lint检查工具，所以一共三个命令：12345&quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build --modern&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot;&#125;, 在开发阶段，CLI工具会充分利用webpack4在development模式下内置的调试工具以及热更新、热替换等进行构建优化。而翻看npm run build后的代码，发现打包后的代码跟我自己之前手动配置的差别很大。于是我开始查阅相关资料，了解Vue CLI3背后的配置以及其原理。 观察打包后的js文件，首先会发现每个chunk都会有两个副本，其中一个副本在文件名后面添加了legacy后缀名，另一个则没有。而在html文件中，给引入带有legacy后缀js文件的script标签添加了nomodule属性，另一个script标签则添加了type=module属性。通过查阅type=module属性的作用可以了解到，在当下，对于大部分用户而言，我们根本不需要把代码编译到 ES5，不仅体积大，而且运行速度慢。我们需要做的，就是把代码编译到 ES2015+，然后为少数使用老旧浏览器的用户保留一个 ES5 标准的备胎即可。其核心原理在于依赖 &lt;script type=”module”&gt;的支持来分辨浏览器对 ES2015+ 代码的支持，并且可以用&lt;script nomodule&gt;进行优雅降级。支持 &lt;script type=”module”&gt; 的浏览器，必然支持下面的特性： async/await Promise Class 箭头函数、Map/Set、fetch 等等… 而不支持 &lt;script type=”module”&lt; 的老旧浏览器，会因为无法识别这个标签，而不去加载 ES2015+ 的代码。另外老旧的浏览器同样无法识别nomodule 属性，会自动忽略它，从而加载 ES5 标准的代码。 123&lt;script type=&quot;module&quot; src=&quot;app.js&quot;&gt;&lt;/script&gt;&lt;script nomodule src=&quot;app-legacy.js&quot;&gt;&lt;/script&gt; // legacy 是遗产的意思，在这里面是老旧的意思，理解成老旧的语法 想要支持module和nomodule的核心就是 Babel7的插件预设babel-preset-env。babel-preset-env将基于实际浏览器以及运行环境，自动确定babel插件以及polyfill，转义ES2015以及此版本以上的语法。而该preset的esmodules属性可以让我们直接编译到 ES2015+ 的语法。改造一下webpack，构建两次，分别用不同的 babel 配置，就可以编译出两份文件。CLI引入了@vue/babel-preset-app插件来提供babel-preset-env的功能，插件支持用户构建应用程序、UMD或原生web组件，其配置如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// @vue/babel-preset-app/index.js// resolve targets let targets if (process.env.VUE_CLI_BABEL_TARGET_NODE) &#123; // running tests in Node.js targets = &#123; node: &apos;current&apos; &#125; &#125; else if (process.env.VUE_CLI_BUILD_TARGET === &apos;wc&apos; || process.env.VUE_CLI_BUILD_TARGET === &apos;wc-async&apos;) &#123; // targeting browsers that at least support ES2015 classes // https://github.com/babel/babel/blob/master/packages/babel-preset-env/data/plugins.json#L52-L61 targets = &#123; browsers: [ &apos;Chrome &gt;= 49&apos;, &apos;Firefox &gt;= 45&apos;, &apos;Safari &gt;= 10&apos;, &apos;Edge &gt;= 13&apos;, &apos;iOS &gt;= 10&apos;, &apos;Electron &gt;= 0.36&apos; ] &#125; &#125; else if (process.env.VUE_CLI_MODERN_BUILD) &#123; // targeting browsers that support &lt;script type=&quot;module&quot;&gt; targets = &#123; esmodules: true &#125; &#125; else &#123; targets = rawTargets &#125; // included-by-default polyfills. These are common polyfills that 3rd party // dependencies may rely on (e.g. Vuex relies on Promise), but since with // useBuiltIns: &apos;usage&apos; we won&apos;t be running Babel on these deps, they need to // be force-included. let polyfills const buildTarget = process.env.VUE_CLI_BUILD_TARGET || &apos;app&apos; if ( buildTarget === &apos;app&apos; &amp;&amp; useBuiltIns === &apos;usage&apos; &amp;&amp; !process.env.VUE_CLI_BABEL_TARGET_NODE &amp;&amp; !process.env.VUE_CLI_MODERN_BUILD ) &#123; polyfills = getPolyfills(targets, userPolyfills || defaultPolyfills, &#123; ignoreBrowserslistConfig, configPath &#125;) plugins.push([ require(&apos;./polyfillsPlugin&apos;), &#123; polyfills, entryFiles, useAbsolutePath: !!absoluteRuntime &#125; ]) &#125; else &#123; polyfills = [] &#125; 翻看@vue/cli-service模块的源码， 我在里面找到CLI为了支持处理模板中的 module 和 nomodule 属性而引入的webpack插件：ModernModePlugin。该插件暴露了一个es6类，在该类的prototype属性上的apply方法定义如下：1234567apply (compiler) &#123; if (!this.isModernBuild) &#123; this.applyLegacy(compiler) &#125; else &#123; this.applyModern(compiler) &#125;&#125; isModernBuild属性表示当前构建是否生成ES2015+版本的代码。若是为false，则调用applyLegacy方法，并把编译器对象作为参数传递过去：12345678910111213141516applyLegacy (compiler) &#123; const ID = `vue-cli-legacy-bundle` compiler.hooks.compilation.tap(ID, compilation =&gt; &#123; compilation.hooks.htmlWebpackPluginAlterAssetTags.tapAsync(ID, async (data, cb) =&gt; &#123; // get stats, write to disk await fs.ensureDir(this.targetDir) const htmlName = path.basename(data.plugin.options.filename) // Watch out for output files in sub directories const htmlPath = path.dirname(data.plugin.options.filename) const tempFilename = path.join(this.targetDir, htmlPath, `legacy-assets-$&#123;htmlName&#125;.json`) await fs.mkdirp(path.dirname(tempFilename)) await fs.writeFile(tempFilename, JSON.stringify(data.body)) cb() &#125;) &#125;)&#125; 若为false，则调用applyModern方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// use &lt;script type=&quot;module&quot;&gt; for modern assetsdata.body.forEach(tag =&gt; &#123; if (tag.tagName === &apos;script&apos; &amp;&amp; tag.attributes) &#123; tag.attributes.type = &apos;module&apos; &#125;&#125;)// use &lt;link rel=&quot;modulepreload&quot;&gt; instead of &lt;link rel=&quot;preload&quot;&gt;// for modern assetsdata.head.forEach(tag =&gt; &#123; if (tag.tagName === &apos;link&apos; &amp;&amp; tag.attributes.rel === &apos;preload&apos; &amp;&amp; tag.attributes.as === &apos;script&apos;) &#123; tag.attributes.rel = &apos;modulepreload&apos; &#125;&#125;)// inject links for legacy assets as &lt;script nomodule&gt;const htmlName = path.basename(data.plugin.options.filename)// Watch out for output files in sub directoriesconst htmlPath = path.dirname(data.plugin.options.filename)const tempFilename = path.join(this.targetDir, htmlPath, `legacy-assets-$&#123;htmlName&#125;.json`)const legacyAssets = JSON.parse(await fs.readFile(tempFilename, &apos;utf-8&apos;)) .filter(a =&gt; a.tagName === &apos;script&apos; &amp;&amp; a.attributes)legacyAssets.forEach(a =&gt; &#123; a.attributes.nomodule = &apos;&apos; &#125;)if (this.unsafeInline) &#123; // inject inline Safari 10 nomodule fix data.body.push(&#123; tagName: &apos;script&apos;, closeTag: true, innerHTML: safariFix &#125;)&#125; else &#123; // inject the fix as an external script const safariFixPath = path.join(this.jsDirectory, &apos;safari-nomodule-fix.js&apos;) const fullSafariFixPath = path.join(compilation.options.output.publicPath, safariFixPath) compilation.assets[safariFixPath] = &#123; source: function () &#123; return new Buffer(safariFix) &#125;, size: function () &#123; return Buffer.byteLength(safariFix) &#125; &#125; data.body.push(&#123; tagName: &apos;script&apos;, closeTag: true, attributes: &#123; src: fullSafariFixPath &#125; &#125;)&#125;data.body.push(...legacyAssets)await fs.remove(tempFilename)cb()// 在 htmlWebpackPlugin 处理好模板的时候再处理下，把页面上 &lt;script nomudule=&quot;&quot;&gt; 处理成 &lt;script nomudule&gt;compilation.hooks.htmlWebpackPluginAfterHtmlProcessing.tap(ID, data =&gt; &#123; data.html = data.html.replace(/\\snomodule=&quot;&quot;&gt;/g, &apos; nomodule&gt;&apos;)&#125;) ios10.3版本有个bug，不支持 nomodule 属性，这样带来的后果就是 10.3 版本的 IOS 同时执行两份 JS 文件。有个hack写法可以解决这个问题：123456789101112131415161718192021// 这个会解决 10.3 版本同时加载 nomodule 脚本的 bug，但是仅限于外部脚本，对于内联的是没用的// fix 的核心就是利用 document 的 beforeload 事件来阻止 nomodule 标签的脚本加载(function() &#123; var check = document.createElement(&apos;script&apos;); if (!(&apos;noModule&apos; in check) &amp;&amp; &apos;onbeforeload&apos; in check) &#123; var support = false; document.addEventListener(&apos;beforeload&apos;, function(e) &#123; if (e.target === check) &#123; support = true; &#125; else if (!e.target.hasAttribute(&apos;nomodule&apos;) || !support) &#123; return; &#125; e.preventDefault(); &#125;, true); check.type = &apos;module&apos;; check.src = &apos;.&apos;; document.head.appendChild(check); check.remove(); &#125;&#125;()); 这段代码被ModernModePlugin引入并定义在常量safariFix中。参考链接： Webpack 构建策略 module 和 nomodule React 16 加载性能优化指南","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://rhliu228.github.io./blog/tags/webpack/"},{"name":"babel","slug":"babel","permalink":"https://rhliu228.github.io./blog/tags/babel/"},{"name":"vue-cli3","slug":"vue-cli3","permalink":"https://rhliu228.github.io./blog/tags/vue-cli3/"}]},{"title":"字符编码归纳","slug":"CharacterEncoding","date":"2019-05-16T12:57:35.000Z","updated":"2019-08-04T13:50:28.360Z","comments":true,"path":"CharacterEncoding/","link":"","permalink":"https://rhliu228.github.io./CharacterEncoding/","excerpt":"这篇文章主要是对ASCII，UTF-8，Unicode，GBK编码等概念进行阐述并加以区别。","text":"这篇文章主要是对ASCII，UTF-8，Unicode，GBK编码等概念进行阐述并加以区别。首先阐述三个跟字符相关的概念： 字符表：要显示的字符的集合 字符编码：字符表中的字符对应的二进制表示 字符集：定义了一种规则，将一串二进制数字解释为一个字符 例如，unicode给世界上的字符赋予一个独一无二的二进制编码，这是字符集方案，但是却没有定义字符是如何传输和存储的，而utf-8则是基于unicode的一种编码方案实现。 1. ASCIIASCII是美国制定的字符编码，使用一个字节（8bit）存储字符，一共规定了128个字符的编码，最前面的一位统一规定为0。其中0-32号字符用于特殊用途的控制码，33-127号字符表示大小写字母和数字。ASCII扩展字符集利用了字节前面的最高位，这样字符便扩展到255个，扩展的128-255字符主要用于横线、竖线、交叉等形状。 2. 中文编码 GB2312GB2312是对ASCII的中文扩展，在这种情况下，原来 0 – 127 号字符代表的含义不变，这就是半角字符。但是两个大于127的字节连在一起时，就代表GB2312编码的字符。这两个字节的范围是：第一个字节范围是[0xA1(161),0xF7(247)]，第二个字节的范围是[0xA1(161),0xFE(254)]共收录了6763个汉字，还包括拉丁字母，希腊字母和日文字符，并对ASCII字符里已有的数、标点、字母赋予两个字节的编码，这就是全角字符。、 GBKGB2312仅包含了常用汉字，没有编码生僻字以及繁体字，GBK就对其进行了扩展。只要第一个字节大于127，不管后面的字节是否大于127，就是GBK编码的字符。这两个字节的范围是：第一个字节的范围是[0x81(127),0xFE(254)]，第二个字节的范围是[0x40(64),0x7E(126)]U[0x80(128),0xFE(254)]GBK包含了GB2312的所有内容，提供了23940个编码，使用了21886个。 GB18030把两个字节在GBK中还没有用完的码位用来编码一些少数民族的语言 （GB2312,GBK,GB18030）最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里(这几种编码方案，同时用1个字节和两个字节编码)，因此写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。 3.unicode中文采用GB类进行编码，但是其他国家也同样存在着各种编码方式，这样极其容易造成乱码。而unicode对世界上大部分的文字系统进行了整理、编码。但unicode只定义了符号的二进制代码，并没有规定这个二进制编码如何存储。若是要在计算机里存储unicode编码，有两个问题： 第一个问题是如何区分unicode和ASCII，计算机如何知道三个字节代表三个符号还是一个符号。 采用定长的字节表示unicode字符，比如三个或者四个，对于只用一个字节就能表示的英文字母来说，会造成很大的存储空间浪费，每个英文字母前面必然有2到3个字节是0。这造成的结果是 ，出现了unicode的多种存储方式，导致unicode在很长时间内无法推广 4.utf-8utf的含义是UCS Transfer Format，这是随着互联网的普及而诞生的统一的编码方式。utf-8是在互联网上使用最广的一种unicode的实现方式。其他方式还包括UTF-16、UTF-32，不过在互联网上基本不用。utf-8的最大特点，就是它是一种变长的编码方式，使用1-4个字节表示一个符号，根据不同的符号变换字节长度。其编码规则是： 单字节的字符，第一位统一为0，后面七位是这个符号的unicode编码，utf-8码只占用一个字节，和ASCII码完全相同。 对于n（n&gt;1）个字节的字母,第一个字节的前n位设为1，第n+1位设置为0，后面字节的前两位都设为10，这n个字节的其余空位用来填空这个字符的unicode编码，高位用0补足。 Unicode范围 编码格式 剩余位数 000000-00007F 0xxxxxxx 7 000080-0007FF 110xxxxx 10xxxxxx 11 000800-00FFFF 1110xxxx 10xxxxxx 10xxxxxx 16 010000-10FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 21 由此可以总结出字符用UTF-8编码的规律： 4个字节的utf-8十六进制编码一定是F开头 3个字节的utf-8十六进制编码一定是E开头 2个字节的utf-8十六进制编码一定是C或者D开头 1个字节的utf-8十六进制编码一定是小于8开头 utf-16以两个字节为单位进行编码。utf-8需判断每个字节的开头标志信息，可能解析出错。而utf-16不会判断开头标志，即使错也是错一个字符，容错能力强。Javascript内部，字符以utf-16的格式存储，每个字符两个字节。对于那些需要四个字节表示的unicode字符（unicode码点大于0xFFFFF），javascript会认为它们是两个字符。不过可以参考es6中关于字符串的扩展，看看是如何解决这个问题的… 参考 字符编码笔记：ASCII，Unicode和UTF-8 —— 阮一峰","categories":[],"tags":[{"name":"字符编码","slug":"字符编码","permalink":"https://rhliu228.github.io./blog/tags/字符编码/"}]},{"title":"深入理解Javascript中的数字","slug":"NumberInJs","date":"2019-04-02T11:05:00.000Z","updated":"2019-09-14T13:33:30.512Z","comments":true,"path":"NumberInJs/","link":"","permalink":"https://rhliu228.github.io./NumberInJs/","excerpt":"我们知道，在java中，数字会分为整型和浮点型，其中浮点型区分为单精度跟双精度格式。但是在JS中，只有Number型，并不区分整型跟浮点型，数字统一采用IEEE 754标准的64位双精格式进行存储。","text":"我们知道，在java中，数字会分为整型和浮点型，其中浮点型区分为单精度跟双精度格式。但是在JS中，只有Number型，并不区分整型跟浮点型，数字统一采用IEEE 754标准的64位双精格式进行存储。 1. IEEE 754的双精度IEE754浮点数有三个基本构成：符号域(S)、指数域(E)、尾数域(M)。给定数值V，用双精度浮点数表述为1V = (-1)^S×2^*(E-1023)*1.M 其中符号域S，指数E,尾数域M定义为： 符号域S：占1位 （0代表正数，1代表负数） 指数E：占11位，也叫阶码（exponent），表示2的幂，它的作用是对浮点数加权。 阶码 = 阶码真值 + 偏移量 尾数域(M)：占52位，M是二进制小数。 顺便提一下，32位单精度由1位符号位+8位阶码+23位尾数构成。 1.1 为什么会有偏移量102311位指数表示范围为[-1024,1023], 需要引入符号位，例如将高位置1表示负数，这样0-1023表示正数，1024-2047表示负数。但这会给机器比较数字大小带来麻烦（例如机器会认为2000比1023大，但实际上2000表示的是一个负数）。为了简化操作，可以考虑整体偏移1024位，变成[0,2047],要想得到原来的数字，只需要将存储数字减少1024即可。但由于数字0和2047适用于非规格化的情况，只能特殊处理（后面会介绍什么是规格化），去除了2个数字，所以用1023作偏移量即可。这种通过偏移，使得所有的数可以不用去考虑其符号的方法叫余码系统。经过以上处理，可以将指数的真实值称为阶码真值，阶码真值与偏移量相加得到阶码，阶码就是实际存储在机器上的数字。 1.2 尾数M实际有多少位同一浮点数的表示方法有很多种，但规范一般采用科学计数法，二进制只有0和1，那么按照科学计数法，首位只可能是1，对此IEEE省略了默认的1，所以实际上有效尾数是有53位的。这时会出现一个问题， 尾数M省略的1是一定会存在的，以至于无法表示0，不过IEEE 754早就想到了这个问题。 1.3 E阶码取值E阶码分为三种情况： 规格化： S + (E!=0 &amp;&amp; E!=2047) + 1.M。此时阶码不能为0也不能为2047，只有这种情况，尾数域才会有隐含位1。 非规格化：此时E全为0，即阶码真值为-1023，如果尾数M全为0，则浮点数表示正负0；否则表示那些非常接近于0.0的数。 E全为1: 此时如果尾数域全为0，则表示Infinity和-Infinity，否则表示NaN：S + 11111111111 + (M!=0) 。 2. 数字的范围数字的范围有两个概念，一是最大正数和最小负数，二是最小正数和最大负数，即[最小负数，最大负数]并上[最小正数，最大正数]。从S、E、M三个维度看，S代表正负，E阶码值远大于M尾数个数，所以S决定大小，M决定精度。下面以E阶码分两种情况分析： 2.1 规格化规格化下，当E取最大值，即2046时，阶码真值为2046-1023=1023，从指数上看，数值范围是[-2^1023,2^1023]。JS函数计算Math.pow(2,1023)的结果是8.98846567431158e+307，如果尾数全为1，即1.1111111111 1111111111 1111111111 1111111111 1111111111 11，非常接近于2，将8.98846567431158e+307乘以2，得到的结果约等于1.7976931348623157e+308。这个值就是我们用JS常量Number.MAX_VALUE获取到的，两者非常接近，所以数字的范围是[-1.7976931348623157e+308,1.7976931348623157e+308]。如果数字绝对值超过1.7976931348623157e+308，则数字太大或者太小，在JS显示为Infinity和-Infinity，称为正向溢出。 2.2 非规格化非规格化的情况下，E取值为0，阶码真值为-1023，指数最小值是2^1023，然而尾数等于0.0000000000 0000000000 0000000000 0000000000 0000000000 01，52位尾数还能虚拟化地向右移动51位，所以最小值是2^(-1074) = Math.pow(2,2074) 约等于5e-324。JS常量Number.MIN_VALUE就等于5e-324。所以(-5e-324,5e-324)之间的数比可表示的最小的数还要小，叫反向溢出。 3.JS 整数的安全范围从M尾数分析，精度最多是53位，这决定了整数的安全范围远远小于Number.MAX_VALUE。如M取最大值：1.1111111111 1111111111 1111111111 1111111111 1111111111 11，E取52，则得到的结果是2^53-1,得到的结果是9007199254740991。而在ES6中，能够被“安全”呈现的最大整数是Number.MAX_SAFE_INTEGER，等于9007199254740991；最小整数是-9007199254740991，在ES6被定义为Number.MIN_SAFE_INTEGER。 4. 较小的数值比较二进制浮点数的最大问题，是会出现以下情况：10.1 + 0.2 === 0.3 // false 因为尾数M只有52位，这决定了0.1和0.2不是十分精确，它们的相加结果并非刚好等于0.3，而是一个比较接近的数字0.30000000000000004，所以条件判断为false。为了判断0.1+0.2和0.3是否相等，最常见的方法是设置一个误差范围值，通常称为“机器精度”，对于JavaScript来说，这个值通常是2^-52(2.220446049250313e-16)。从ES6中开始，这个值被定义在Number.EPSILON中。 5. 32位有符号整数虽然整数最大能够达到53位，但是有些数字操作（如数位操作）只适用于32位数字，所以这些操作中数字的安全范围就要小很多，变成从Math.pow(-2,31)(-2147483648)到Math.pow(2,31)(2147483648)。例如 a|0 可以将a中的数值转换为32位有符号整数 6. 32位无符号整数Javascript数组下标值的范围为0到2^32-1。对于任意给定的数字下标值，如果不在此范围内，js会将它转换为一个字符串，并将该下标对应的值作为该数组对象的一个属性值而不是数组元素。如果该下标值在合法范围内，则无论该下标值是数字还是数字字符串，都一律会被转化为数字使用，即 array[“0”] = 0 和 array[0] = 0 执行的是相同的操作。 7. 总结用数轴来表示JS中各个Number常量的大小如下： JS 32位整数 64位双精度 场景 数组索引，位运算 Number 整数范围 数组索引：[0,2^32-1]，位运算：[-2^31,2^31] [-2^53-1,2^53-1] 可表示的数范围 同上 [-1.7976931348623157e+308,-5e-324]U [5e-324, 1.7976931348623157e+308] 精度 1 2^-52 参考 深入理解IEEE 754的64位精度","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://rhliu228.github.io./blog/tags/Javascript/"}]},{"title":"深入浅出RxJS总结","slug":"RxJS","date":"2019-03-15T08:01:00.000Z","updated":"2019-06-15T11:09:28.089Z","comments":true,"path":"RxJS/","link":"","permalink":"https://rhliu228.github.io./RxJS/","excerpt":"很早就在一些博客和书籍上了解到，javascript是一门具备函数式编程特性的语言，虽然在日常工作也会接触到js的闭包，函数绑定，函数柯里化等概念，但对于函数式编程的特点和优势，一直一知半解。加之在工作中总会遇到异步处理的糟糕代码，所以前段时间花了一些功夫在阅读程墨著作的《深入浅出RxJS》上。总的来说，RxJS是Reactive Extension(也叫ReactiveX)编程理念的javascript版本。Reactive Extension是实践响应式编程的一套工具，其诞生的主要目的是解决异步处理的问题，但这并不表示Rx不适合同步的数据处理。这篇文章主要总结自己阅读《深入浅出RxJS》的一些思考，关于RxJS的具体使用可参考ReactiveX。","text":"很早就在一些博客和书籍上了解到，javascript是一门具备函数式编程特性的语言，虽然在日常工作也会接触到js的闭包，函数绑定，函数柯里化等概念，但对于函数式编程的特点和优势，一直一知半解。加之在工作中总会遇到异步处理的糟糕代码，所以前段时间花了一些功夫在阅读程墨著作的《深入浅出RxJS》上。总的来说，RxJS是Reactive Extension(也叫ReactiveX)编程理念的javascript版本。Reactive Extension是实践响应式编程的一套工具，其诞生的主要目的是解决异步处理的问题，但这并不表示Rx不适合同步的数据处理。这篇文章主要总结自己阅读《深入浅出RxJS》的一些思考，关于RxJS的具体使用可参考ReactiveX。 函数响应式编程RxJS引用了两个重要的编程思想：函数式和响应式 函数式编程函数式编程是强调使用函数来解决问题的一种编程范式。其对函数的使用有一些特殊的要求： 声明式和声明式编程相对的是命令式编程，命令式编程强调将计算逻辑以指令的方式描述出来： 1234567function double(arr)&#123; const result = []; for(let i =0; i&lt;arr.length; i++) &#123; result.push(arr[i]*2); &#125; return result;&#125; 而声明式编程则把运算过程尽量写成一系列嵌套的函数调用： 1const double = arr =&gt; arr.map(item =&gt; item * 2); 在javascript中，函数具有一等公民的地位，一个函数可以作为参数传递给另一个函数，才让map这种功能实现成为了可能。 纯函数所谓纯函数，满足了以下条件 函数的执行过程完全由输入参数决定，不会受除参数之外的任何数据影响. 函数不会修改任何外部状态，比如修改全局变量或传入的参数对象. 数据不变性程序要发生变化，不应该修改现有的数据，而是应该通过产生新的数据来体现这种变化。不可变的数据就是Immutable的数据。 顺便对比一下函数式编程和面向对象编程。这两种编程方式都可以让代码更加容易理解，但方式不同。面向对象的方法把状态的改变封装起来，外部不能直接操作数据，只能通过类提供的实例方法来读取修改数据，限制了对数据的访问方式，这就制止了毫无节制的数据修改。但是面向对象却把数据的修改历史完全隐藏起来，这种不确定性导致代码可维护性下降。而函数式编程则是尽量减少发生变化的部分，数据就是数据，函数就是函数，函数可以处理数据，通过产生新的数据作为运算结果，以此让代码更加清晰。 从本质上说，javascript并不是纯粹意义的函数式编程语言，javascript并没有强制要求数据不变性，编写的函数也不能保证没有副作用，但是javascript的函数拥有第一公民的身份，由此可以很方便地应用函数式编程的许多思想。More info:函数式编程入门教程函数式编程初探 响应式编程 响应式编程是一种面向数据流和变化传递的编程范式。 数据流可以通过多种方式创造出来，流对象中流淌的是数据，数据流会通过各种管道，这些管道会对数据进行各种转化处理，RxJS的核心就是使用和组合各种操作符，构成管道，对流经其中的数据进行处理。 Observable 和ObserverObserver和Obeservable是RxJS的两个重要概念。Obeservable就是“可被观察的对象”，而Observer就是观察者，连接两者的桥梁就是Observable对象的函数subscribe。每个Observable对象，代表的就是在一段时间范围内发生的一系列事件。RxJs结合了观察者模式和迭代器模式，其中的Observable等同于： 1Observable = Publisher + Iterator 观察者模式观察者模式将逻辑分为发布者和观察者，其中生产者只负责产生事件，它会通知所有注册挂上号的观察者，而不关心这些观察者如何处理这些事件，相对的，观察者可以被注册上某个发布者，只管接收到事件之后就处理，而不关心这些数据是如何产生的。在RxJS的世界中，Observable对象就是一个发布者，通过Observable对象的subscribe，可以把这个发布者和某个观察者连接起来。观察者使得复杂的问题被分解成三个小问题： 如何产生事件，这是发布者的责任，在RxJS中是Observable对象的工作。 如何响应事件，这是观察者的责任，在RxJS中由subscribe的参数来决定。 什么样的发布者关联什么样的观察者，也就是何时调用subscribe。 迭代器模式迭代器指的是能够遍历一个数据集合的对象，数据集合的实现方式有很多，比如数组，单向链表等，迭代器的作用就是提供一个通用的接口，让使用者完全不用关心这个数据集合的集合的实现方式。迭代器的另一个名字叫游标（cursor）,就像一个移动的指针一样，从集合中的一个元素移动到另一个元素，完成对整个集合的遍历。迭代器的实现方式有很多，通常包含以下几个函数： getCurrent，获取当前被游标指向的元素 moveToNext，将游标移动到下一个元素，调用这个函数之后，getCurrent获得的元素就会不同 isDone， 判断是否已经遍历完所有的元素上面说的三个函数，是“拉”式迭代器的实现，而RxJs实现的是“推”式的迭代器的实现。因为在RxJS中，作为迭代器的使用者，并不需要主动从Observable中“拉”数据，而是只要subscribe上Observable对象之后，自然就能接收到消息的推送，这就是观察者模式和迭代器模式结合的强大之处。下面是一段代码： 12345const iterator = getIterator();while(!iterator.isDone())&#123; console.log(iterator.getCurrent()); iterator.moveToNext();&#125; 以下这段代码说明了Observable在完结，出错处理以及向下游传递数据时如何通知下游。1234567891011121314151617181920212223242526272829303132333435363738const onSubscribe = observer =&gt; &#123; let number = 1; const handle = setInterval(() =&gt; &#123; observer.next(number++); &#125;,1000); return &#123; unsubscribe: () =&gt; &#123; clearInterval(handle); &#125; &#125;&#125;// 完结和出错处理const onSubscribe = observer =&gt; &#123; observer.next(1); // 向下游传递完结信号 observer.complete(); // or 向下游传递错误信号 //注意，一个Observable对象只能有一种终结状态，要么是完结，要么是出错，所以调用了complete之后再调用error函数是无法引发下游的错误处理函数调用的，反之亦然。 //observer.error(&apos;wrong&apos;);&#125;const source$ = new Observable(onSubscribe);const theObserver = &#123; next: item =&gt; console.log(item), error: err =&gt; console.log(err), complete: () =&gt; console.log(&apos;No more Data)&#125;const subscription = source$.subscribe(theObserver);// 也可以简写为// const subscription = source$.subscribe(// item =&gt; console.log(item),// err =&gt; console.log(err),// complete: () =&gt; console.log(&apos;No more Data)//);setTimeout(() =&gt; &#123; //退订Observable subscription.unsubscribe();&#125;,3500); 操作符一个Observable对象代表的是一个数据流，实际工作中，产生Observable对象并不是每次都直接调用Observable构造函数来创建数据流对象，Rxjs已经贴心地为我们实现了常用的创建类操作符。这里说的创造，并不只是说返回一个Observable对象，而是指这些操作符不依赖于其他Observable对象，这些操作符可以凭空或者根据其他数据源（外部js事件，promise，ajax等）创造出一个Observable对象。事实上，对于复杂情况，并不会创建了一个数据流之后就直接subscribe一个Observer，往往需要各类操作符对数据流做一系列的处理，再交给Observer，就像一个管道，数据从管道的一段流入，途经管道的各个环节，位于管道末端的Observer只需要处理能够走到终点的数据。 组成数据管道的元素就是操作符，操作符的本质是返回一个Observable对象的函数。对于每一个管道，链接的就是上游和下游。 在数据管道中流淌的数据就像水，从上游流向下游。对于一个操作符来说，上游可能是一个数据源，也可能是其他操作符，下游可以是最终的观察者，也可能是另一个操作符。每个操作符都会满足 返回一个全新的Observable对象 对上游和下游的订阅和退订处理。 处理异常情况 及时释放资源 操作符分类功能分类根据功能，操作符可以分为以下类别 创建类，包括create, of, range, generate, repeat和repeatWhen, empty, throw, never, inteval和timer, from, from Promise, from event和fromEventPattern, ajax, defer. 转化类，包括map, mapTo, pluck, windowTime、 windowCount、windowWhen、windowToggle、和window, bufferTime、bufferCount、bufferWhen、bufferToggle和buffer, concatMap、mergeMap、switchMap、exhaustMap, scan和mergeScan 过滤类，包括filter, first, last, take, takeLast, takeWhile和takeUntil, skip, skipwhile和skipUntil, throttleTime、debouceTime和auditTime, throttle、debouce和audit, sample和sampleTime, distnct, distinctUntilChanged和distinctUntilKeyChanged, ignoreElements, elementAt, single 合并类，包括concat和concatAll, merge和mergeAll, zip和zipAll, combineLatest、combineAll和withLatestFrom, race, startWith, forkJoin, switch和exhaust 多播类，包括multicast, publishLast, publishReplay, publishBehavior 错误处理类，包括catch, retry和retryWhen, finally 辅助工具类，包括concat, max和min, Reduce, every, find和findIndex, isEmpty, defaultEmpty 静态和实例分类 操作符还可以从存在形式进行分类，具体来说就是操作符的实现函数和Observable类的关系。对于定义在Observable类的静态函数，我们称之为静态操作符，而定义在由Observable类prototype属性指向的原型对象上的实例函数，则被称为实例操作符。在链式调用中，静态操作符只能出现在首位，而实例操作符可以出现在任何位置。有些操作符既可以作为Observable类的静态方法，又可以作为Observable对象的实例方法，比如merge。（此处涉及javascript的原型链知识以及es6的class，建议不太了解的读者查阅其他资料了解） 操作符的实现操作符函数实现1234567891011121314151617181920212223242526function map(project) &#123; return new Observable(observer =&gt; &#123; const sub = this.subscribe(&#123; next: value =&gt; &#123; //处理异常情况 try&#123; observer.next(project(value)) &#125; catch(err) &#123; observer.error(error); &#125; &#125;, error: error =&gt; observer.error(error), complete: () =&gt; observer.complete() &#125;); //订阅和退订处理 return &#123; unsubscribe: () =&gt; &#123; sub.unsubscribe(); &#125; &#125; &#125;)&#125;//使用es6箭头函数将会出错，因为此时this将直接绑定为定义函数环境下的this//const map = (project) =&gt; &#123; //这个函数体内的this并不是Observable对象本身//&#125; 可以看到，map利用new关键字创造了一个Observable对象，函数返回的结果就是这个对象，如此一来，map可以链式调用，可以在后面调用其他的操作符，或者调用subscribe增加Observer。这里的this代表的是上游的Observer对象，所以，可以直接使用subscribe订阅其中的事件，对于next事件，调用project函数，把推送的数据做映射，然后传递给下游，对于error和complete事件，map全部转手给下游处理。 操作符关联Observablemap函数编写完毕之后，需要将这个函数与observable关联起来。 给Observable打补丁打补丁就像是给Observable类添加一点功能。map操作符需要一个上游Observable对象，所以它是一个实例操作符，需要赋值给Observable的prototype：1Observable.prototype.map = mao; 如果是一个静态操作符，则直接赋给Observable类的某个属性。 使用bind绑定Observable对象有时候，我们并不希望一个操作符影响所有的Observable对象，为了不覆盖RxJS的map操作符，可以让自定义的操作符只对指定的Observable对象可用，这时可以用bind：1const result$ = map.bind(source$)(x =&gt; x*2); 也可以用call：1const result$ = map.call(source$,x =&gt; x*2); 使用bind有一个缺点，就是上游Observable只能作为操作符函数的参数，这样没法用链式调用，比如，想要连续使用两个map：1const result$ = map.bind(map.bind(source$)(x =&gt; x*2))(x =&gt; x+1); 为了克服这个缺点，可以使用“绑定操作符”，绑定操作符是两个冒号，运算的时候绑定操作符后面的函数，但是保证函数运行时this是绑定操作符前面的对象，这样就可以使用链式调用：1const result$ = source$::map(x=&gt;x*2)::map(x=&gt;x+1); 绑定操作符并不是es6的标准语法，但它会出现在未来的es版本中，浏览器并不支持这种操作符。 使用liftRxJS v5对架构有很大的调整，很多操作符都会用一个神奇的lift函数实现，lift的含义是“提升”，功能是把Observable对象提升一个层次，赋予更多功能。lift是Observable的实例函数，它会返回一个新的Observable对象，通过传递给lift的函数参数可以赋予这个新的Observable对象特殊功能。使用lift实现map： 123456789101112131415function map(project) &#123; return this.lift(function(source$) &#123; return source$.subscribe(&#123; next: value =&gt; &#123; try&#123; this.next(project(value)) &#125; catch(err) &#123; this.error(error); &#125; &#125;, error: err =&gt; this.error(err), complete: () =&gt; this.complete(), &#125;); &#125;);&#125; this代表的是Observer对象，参数source$代表上游的Observable对象。 改进的操作符定义操作符和Observable关联的缺陷js模块导入的代码并不都会被执行，打包工具（rollup，webpack等）的Tree shaking主要用于在js代码打包过程中去除无用的死代码，减少js代码的体积。RxJS中操作符挂在Observable类上或者Observable.prototype上，赋值给Observable类和Observable.prototype上的某个属性在Tree shaking看来就是就是有用的代码，所以，所有的操作符，不管真实运行时是否被调用，都会被Tree shaking认为是有用的代码，不会被当作死代码删除。比如，代码引入interval和map两个操作符：12import &apos;rxjs/add/observable/interval&apos;;import &apos;rxjs/add/operator/map&apos;; 假如在程序中interval和map并没有被调用过，这两个操作符也不会被当作死代码。除此之外，用给Observable打补丁的方式导入操作符，每个文件模块影响的都是全局唯一的那个Observable，极其容易因为代码耦合造成问题。 使用call来创建库摒弃给Observable类打补丁的做法，对于静态操作符，直接使用该函数即可，对于实例操作符，使用bind/call方法，让一个操作符只对一个具体的Observable对象生效。12345678910//留意导入路径的不同import &#123;Observable&#125; from &apos;rxjs/Observable&apos;;import &#123;of&#125; &apos;rxjs/observable/of&apos;;import &#123;map&#125; &apos;rxjs/operator/map&apos;;Observable.prototype.double = function() &#123; return this::map(x =&gt; x*2);&#125;const source$ = of(1,2,3);const result$ =source$.double();result$.subscribe(value =&gt; console.log(value)); 上述代码导入的of和map是两个独立的函数，RxJs传统的打补丁的方式，使用的也是observable和operator目录下的代码，例如rxjs/add/observable/of.js文件所做的工作就是导入rxjs/observable/of.js，并把导入的函数挂载到Observable类上：1234&quot;use strict&quot;;var Observable__1 = require(&apos;../../Observable&apos;);var of_1 = require(&apos;../../observable/of&apos;);Observable__1.Observable.of = of_1.of; 使用bind和call方法，避免了Observable被污染的问题。 lettable和pipeable操作符使用bind和call，每个函数体内依然需要访问this，访问this的函数并不是纯函数。另外，使用call也会让RxJS的代码失去类型检查的优势。从RxJS v5.5.0开始，加入了pipeable操作符，也曾称为lettable操作符。 let在lettable操作符提出之前，let操作符就存在了，它接受一个函数作为参数，该函数需要接收一个Observable对象作为上游Observable。123456789import &#123;Observable&#125; from &apos;rxjs/Observable&apos;;import &apos;rxjs/add/observable/of&apos;;import &apos;rxjs/add/operator/map&apos;;import &apos;rxjs/add/operator/let&apos;;const source$ = Observable.of(1,2,3);//double$是一个纯函数，map直接作用于参数obs$const double$ = obs$ =&gt;obs$.map(x=&gt;x*2);const result$ = source$.let(double$);result$.subscribe(console.log); 改进以上代码，让map返回一个函数，从而可以作为let操作符的参数1234567891011121314151617181920function map(project) &#123; return function(obs$)&#123; return new Observable(observer =&gt; &#123; return obs$.subscribe(&#123; next: value =&gt; &#123; //处理异常情况 try&#123; observer.next(project(value)) &#125; catch(err) &#123; observer.error(error); &#125; &#125;, error: error =&gt; observer.error(error), complete: () =&gt; observer.complete() &#125;); &#125;) &#125;&#125;const result$ = source$.let(map(x=&gt;x*2)); let的作用是把map函数引入到链式调用之中，起到连接上游下游的作用。这里的map函数执行不再是返回一个Observable对象，而是返回一个函数，这个函数才返回Observable对象。，map的实现也看不到对this的访问，在数据管道中上游Observable对象以参数形式传入，而不是靠this获取，让map成为了一个纯函数。从RxJS v5.5.0开始，加入了pipeable操作符，大部分操作符都有pipeable操作符实现，除了： 静态操作符 拥有多个上游Observable对象的操作符 因为每一个lettable操作符都是纯函数，且不会作为补丁挂在Observable类上，Tree shaking就能够找到根本不会被用到的操作符并将其去除。但是导入let这个操作符，却需要使用传统的打补丁的形式，所以RxJS让Observable类自带了一个新的操作符，名叫pipe，可以满足let的功能，却不需要像使用let一样导入模块，任何Observable对象都支持pipe1const result$ = source$.pipe(map(x=&gt;x*2)); pipe还具有管道的功能，可以把多个lettable操作符连接起来：123456789import &#123;of&#125; &apos;rxjs/observable/of&apos;;//留意lettable操作符的引入路径import &#123;map,filter&#125; &apos;rxjs/operators&apos;;const source$ = of(1,2,3);const result$ = source$.pipe( filter(x =&gt; x%2 ===0), map(x =&gt; x*2));result$.subscribe(console.log); 有四个操作符比较特殊，传统的操作符名称和pipeable操作符名称不同： do catch switch finally这四个操作符名称都是js的关键字，以打补丁的方式赋值为Observable.prototype对象某个属性值没有问题，但是不能作为函数的标识符出现，这四个操作符对应的lettable操作符分别是 tap catchError switchAll finalize 多播在RxJs中，Observable和Observer的关系，就是前者在播放内容，后者在收听内容，播放内容的方式可以分为三种： 单播（unicast） 广播（broadcast） 多播（multicast）单播是一对一的关系，一个播放者对应一个接听者，广播把消息传播给所有接听者，多播则是有选择性地把消息传递给有需要的接听者。RxJS对单播是绝对支持的，而广播则不是RXJS支持的目标，广播已经有很多现成的解决方法，例如nodeJs中的EventEmitter。 Hot和Cold数据流的差异如果每一次观察者对Observable对象进行subscribe，都会产生一个全新的数据序列的数据流，这样的Observable对象被称为cold observable。RxJS的大部分创建类操作符创建出来的都是cold observable对象，例如inteval，range等。下面是一个单播的例子：123456789101112131415import &#123;interval&#125; &apos;rxjs/observable/of&apos;;import &#123;take&#125; &apos;rxjs/operators&apos;;const tick$ = interval(1000).pipe(take(3));tick$.subscribe(value=&gt;console.log(&apos;observer 1: &apos; + value));setTimeout(() =&gt; &#123; tick$.subscribe(value=&gt;console.log(&apos;observer 2: &apos; + value));&#125;,2000);//console//observer 1: 0//observer 1: 1//observer 2: 0//observer 1: 2//observer 2: 1//observer 2: 2 你可能会以为输出下面的结果：12345//observer 1: 0//observer 1: 1//observer 2: 1//observer 1: 2//observer 2: 2 但是，interval操作符产生的是一个cold observable对象，每次对上游的subscribe都会产生一个新的生产者。而对于一个hot observable，概念上有一个独立于Observable对象的生产者，这个生产者的创建与subscribe的调用没有关系，subscribe的调用只是让Observable对象连接上生产者而已。RxJs中有一些操作符产生的是Hot Observable： fromPromise fromEvent fromEventPattern 这些产生hot observable对象的操作符数据源都在外部，真正的数据源和有没有Observer没有任何关系。而真正的多播，则是不管有多少Observer进行subscribe，推给Observer的数据都是一样的数据源，满足这种条件的，就是hot observable。hot observable和cold observable都具有“懒”的性质，两者的数据管道内逻辑都只有订阅者存在时才执行，但是cold Observable更“懒”，如果没有订阅者，连数据都不会真正产生；对于hot observable来说，没有订阅者的情况下，数据依旧产生，只是不传入数据管道。所以cold observable实现的是单播，而hot observable实现的是多播。 Subject有时候，我们也希望对cold observable实现多播。要把一个cold observable对象转换成一个hot observable，并不是去改变cold observable本身，而是产生一个新的observable对象，包装之前的cold observable对象，这样在数据流管道中，新的observable就成为了下游。要实现这个转化，很明显需要一个“中间人”做串接的事情： 中间人需要提供subscribe方法，让其他人能够订阅自己的数据源 中间人能够有办法接收推送的数据，包括cold observable推送的数据RxJS中，提供了subject类型，subject既有observable的接口，也具有observer的接口。123456789101112import &#123;Subject&#125; from &apos;rxjs/Subject&apos;;import &#123;interval&#125; &apos;rxjs/observable/interval&apos;;import &#123;map&#125; &apos;rxjs/operators&apos;;const subject = new Subject();subject.pipe(map(x=&gt;x*2)).subscribe( value =&gt; console.log(value), err =&gt; console.log(err), () =&gt; console.log(&apos;on complete&apos;));subject.next(1);subject.next(2);subject.complete(); 一个subject对象是一个Observable，所以可以在后面链式调用任何操作符，也可以调用subscribe来添加Observer。一个subject对象同时也是一个Observer，所以也支持next，error和complete方法。 用Subject实现多播12345678910import &#123;Subject&#125; from &apos;rxjs/Subject&apos;;import &#123;interval&#125; &apos;rxjs/observable/interval&apos;;import &#123;map&#125; &apos;rxjs/operators&apos;;const tick$ = interval(1000).pipe(take(3));const subject = new Subject();tick$.subscribe(subject);subject.subscribe(value=&gt;console.log(&apos;observer 1: &apos; + value));setTimeout(() =&gt; &#123; subject.subscribe(value=&gt;console.log(&apos;observer 2: &apos; + value));&#125;,1500); 只需要让Subject对象居于cold observable和observer之间。但是很可惜subject并不是一个操作符，所以无法链式调用，不过可以创建一个新的操作符来达到链式调用的效果:1234567891011Observable.prototype.makeHot = function() &#123; const cold$ = this; const subject = new Subject(); cold$.subscribe(subject); return subject;&#125;const hotTick$ = interval(1000).pipe(take(3)).makeHot();hotTick$.subscribe(value=&gt;console.log(&apos;observer 1: &apos; + value));setTimeout(() =&gt; &#123; hotTick$.subscribe(value=&gt;console.log(&apos;observer 2: &apos; + value));&#125;,1500); 这段代码有个漏洞，可以直接调用makeHot返回的subject对象的next，error或者complete方法来影响下游：1234const hotTick$ = interval(1000).pipe(take(3)).makeHot();hotTick$.complete();//下面的Observer将不会收到任何消息hotTick$.subscribe(value=&gt;console.log(&apos;observer 1: &apos; + value)); subject对象是不能重复使用的，一个subject对象一旦被调用了complete或者error函数，那么，它作为observable的生命周期也就结束了，后续再想利用这个subject对象传递数据给下游，就像泥牛如大海，没有任何反应。为了杜绝这种可能性，对makeHot进行改进，让它返回一个纯粹的Observable对象:123456Observable.prototype.makeHot = function() &#123; const cold$ = this; const subject = new Subject(); cold$.subscribe(subject); return Observable.create((observer) =&gt; subject.subscribe(observer));&#125; makeHot并不是直接返回Subject对象，而是返回一个新的Observable对象，这样就避免了subject直接暴露给外部。 subject可以有多个上游，如果一个subject订阅多个数据流，起到的作用就是把多个数据源的内容汇聚到一个observable，但是这种使用方式却可能引发意想不到的结果。假设其中一个上游调用了subject对象的complete函数，那即使其他上游的数据还没推送完，subject也会因为生命周期的结束，无法再把其他数据推送给下游。任何一个上游数据的完结或者出错都可以终结subject对象的生命，让subject来做合并数据流的工作并不合适，应该让merge来做。当subject有多个observer时，如果某个observer产生了一个错误异常，而且这个异常没有被observer处理，那subject的其他observer都会失败。12345678910111213141516const tick$ = interval(1000).pipe(take(3));const subject = new Subject();tick$.subscribe(subject);const throwOnUnluckyNumber = value =&gt; &#123; if(value==4)&#123; throw new Error(&apos;unlucky number 4&apos;); &#125; return value;&#125;subject.pipe(map(throwOnUnluckyNumber)).subscribe( value=&gt;console.log(&apos;observer 1: &apos; + value))subject.subscribe( value=&gt;console.log(&apos;observer 2: &apos; + value), err=&gt;console.log(err)) 1号observer在遇到数字4的时候遇到错误异常，2号observer因为1号observer没有优雅地处理错误，也被牵连，因为subject对象由于下游1号Observer没有处理错误而被破坏了。可以想象，Subject为了给所有observer推送数据，会有类似的代码：123for(let observer of allObservers)&#123; observer.next(data);&#125; 为了解决这个问题，好的编程实践是让所有的observer都具备对异常错误的处理。12345678subject.pipe(map(throwOnUnluckyNumber)).subscribe( value=&gt;console.log(&apos;observer 1: &apos; + value), err=&gt;console.log(&apos;observer 1 on error: &apos; + err))subject.subscribe( value=&gt;console.log(&apos;observer 2: &apos; + value), err=&gt;console.log(&apos;observer 2 on error: &apos; + err)) 支持多播的操作符RxJs提供了支持多播的一系列操作符，其中最基础的是 multicast share publish multicast是一个实例操作符，能够以上游的Observable为数据源产生一个新的hot observable对象：1const hotSource$ = coldSource$.multicast(new Subject); multicast接收一个subject对象或者一个返回subject对象的函数（可以在subject对象生命终结时重新subscribe上游）作为参数，返回的是一个Observable对象，不过这个对象比较特殊，是Observable子类ConnectableObservable的实例对象。这种对象包含一个connect函数，connect的作用是触发multicast用Subject对象去订阅上游的Observable，如果不调用这个函数，这个ConnectableObservable将不会从上游那里得到任何数据。除此之外，ConnectableObservable还支持自动计数，对Observer的个数进行计数，当第一个Observer对象被添加时，主动去订阅上游，当最后一个Observer退订时，就让中间人Subject退订上游的Cold Observable。这个功能可以借助ConnectableObservable对象的函数refCount实现。除了第一个参数指定一个Subject对象或者指定一个产生Subject对象的工厂方法，multicast还支持第二个参数：selector，这个参数是一个可选参数，它可以使用上游数据任意多次，但不会重复订阅上游数据流。一旦指定selector参数，multicast将不会返回ConnectableObservable对象，而是用selector函数来产生一个Observable对象。selector函数有一个参数shared，这个参数就是multicast第一个参数代表的Subject或者使用工厂方法返回的Subject对象。123456789101112131415161718192021const coldSource$ = interval(1000).pipe(take(3));const selector = shared =&gt; &#123; return shared.pipe(concat(of(&apos;done)));&#125;const tick$ = coldSource$.pipe(multicast(new Subject(),selector));tick$.subscribe( value=&gt;console.log(&apos;observer 1: &apos; + value), err=&gt;console.log(&apos;observer 1 on error: &apos; + err));setTimeout(() =&gt; &#123; tick$.subscribe( value=&gt;console.log(&apos;observer 2: &apos; + value), err=&gt;console.log(&apos;observer 2 on: error: &apos; + err) );&#125;);//console//observer 1: 0//observer 1: 1//observer 1: 2//observer 1: done//observer 2: done publish完全是通过multicast来实现的 1234567function(selector)&#123; if(selector)&#123; return this.multicast(()=&gt;new Subject(),selector); &#125;else&#123; return this.multicast(new Subject); &#125;&#125; shared完全是通过multicast来实现的 123Observable.prototype.shared = function shared() &#123; return this.multicast(() =&gt; new Subject()).refCount();&#125; 除了以上这几个基础的多播操作符外，RxJS还支持三个高级多播操作符： publishList publishReplay publishBehavior关于它们的使用可以自行查阅官网 总结《深入浅出RxJS》这本书较为系统的介绍了RxJS的核心特性和各类操作符，并且书该书结合弹珠图，将代码例子形象生动地描述清楚，给读者提供了很好的入门教程。个人觉得从书中前三章中得到的收获最大，从中了解到RxJS的代码架构、函数式编程的理念和如何实现操作符。后面介绍操作符用途的章节略显冗长，不过其中有些代码的例子特别贴切和生动，让人有眼前一亮的快感。可以看出作者对RxJS各类操作符的了解是非常深刻的。 例如，讲解RxJS的高阶observable，所谓高阶，指的是该Observable返回的依旧是Observable，这样能够管理多个数据流，将管理数据和管理数据流归一化，类似于高阶函数，高阶函数的参数或者返回值是一个函数。这时就需要一些操作符能够组合或者处理这些高阶Observable，将其“砸平”，常见的有合并类高阶操作符concatAll，mergeAll，以及高阶的map等。为了说明高阶map运算符concatMap的用途，作者列举了实现网页拖拽的例子。网页应用中，拖拽就是用户的鼠标在某个dom元素上按下去，然后拖动这个元素，最后松开鼠标的过程，这个过程是重复的，拖拽涉及的事件包括mousedown，mouseup和mousemove，使用传统方式，基本上就是当mousedown事件发生时，用一个变量标识当前进入拖拽状态，然后监听mousemove事件，移动dom元素位置，当mouseup事件发生时，改变状态变量使之标记为“离开拖拽”，等待下一次mousedown事件的发生。这个过程可以看成是多个由mousedown事件引发的数据流序列，每个序列内部又是以mouseup结束的mousemove数据序列。这些序列相互之间不可能交叉重复，这时可以考虑使用高阶map操作符concatMap实现这个例子。详细的代码可参考concatMap example RxJS还有一些非常有意思的特性，包括Scheduler，单元测试等，这些并未在这篇博客中体现，读者可以根据自身需要去了解。 可以得出，只有在项目中使用RxJS，经过大量实践，才能真正掌握RxJS这套工具。我乖乖地合上了这本书，打算找个项目练练手去了。 版本《深入浅出RxJS》这本书的代码依赖的是RxJs v5.5.0之前的版本，大部分操作符都是采用给Observable类打补丁的形式引用的，我在尝试看这本书的时候，RxJS的版本已经是V6.3.3了，在该版本中，将打补丁的形式完全移除，将所有实例操作符改成了pipeable操作符，其目录存放在”rxjs/operators”，静态操作符直接使用，其目录就在”rxjs/index.js”。","categories":[],"tags":[{"name":"函数式编程","slug":"函数式编程","permalink":"https://rhliu228.github.io./blog/tags/函数式编程/"},{"name":"响应式","slug":"响应式","permalink":"https://rhliu228.github.io./blog/tags/响应式/"}]}]}