{"meta":{"title":"Zoe的博客","subtitle":null,"description":null,"author":"Liu.Runhua","url":"https://rhliu228.github.io.","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-06-15T12:38:03.646Z","updated":"2019-06-15T12:38:03.645Z","comments":true,"path":"404.html","permalink":"https://rhliu228.github.io./404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"},{"title":"","date":"2019-06-15T12:46:34.095Z","updated":"2019-06-15T12:46:34.095Z","comments":true,"path":"friends/index.html","permalink":"https://rhliu228.github.io./friends/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-06-15T11:47:00.701Z","updated":"2019-06-15T11:47:00.701Z","comments":true,"path":"about/index.html","permalink":"https://rhliu228.github.io./about/index.html","excerpt":"","text":""},{"title":"","date":"2019-06-15T12:47:21.371Z","updated":"2019-06-15T12:47:21.370Z","comments":true,"path":"projects/index.html","permalink":"https://rhliu228.github.io./projects/index.html","excerpt":"","text":""},{"title":"","date":"2019-06-15T14:56:11.203Z","updated":"2019-06-15T14:56:11.203Z","comments":true,"path":"blog/archives/index.html","permalink":"https://rhliu228.github.io./blog/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-06-15T12:43:45.294Z","updated":"2019-06-15T12:43:45.291Z","comments":true,"path":"blog/categories/index.html","permalink":"https://rhliu228.github.io./blog/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-06-15T12:41:59.278Z","updated":"2019-06-15T12:41:59.278Z","comments":true,"path":"blog/tags/index.html","permalink":"https://rhliu228.github.io./blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"排序算法总结","slug":"Algorithm","date":"2019-07-05T06:00:00.000Z","updated":"2019-07-22T15:24:34.994Z","comments":true,"path":"Algorithm/","link":"","permalink":"https://rhliu228.github.io./Algorithm/","excerpt":"本文对常见的排序算法和它们的空间、时间复杂度进行总结","text":"本文对常见的排序算法和它们的空间、时间复杂度进行总结 排序算法 平均时间复杂度 最好时间复杂度 最坏时间复杂度 空间复杂度 稳定性 插入排序 O(n^2) O(n^2) O(n^2) O(1) Yes 冒泡排序 O(n^2) O(n^2) O(n^2) O(1) Yes 选择排序 O(n^2) O(n) O(n^2) O(1) No 希尔排序 O(n^1.5) O(n^1.5) O(n^2) O(1) No 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) Yes 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) No 快速排序 O(nlogn) O(nlogn) O(n^2) O(logn) No 计数排序 O(n+m) O(n+m) O(n+m) O(n+m) Yes 桶排序 O(n) O(n) O(n) O(m) Yes 计数排序 O(n*k) O(n*k) O(n^2) ? Yes 其中k代表数值中“数字”的个数，n代表数据规模，m代表数据的最大值减去最小值 1. 插入排序插入排序将数组分为有序和无序两部分，每次从无序部分取出一个数字，将其与前面已经排好序的子序列进行比较，并插到有序子序列中的正确位置。12345678910const insertSort = arr =&gt; &#123; for(let i = 1; i&lt; arr.length; i++) &#123; let temp = arr[i]; for(let j = i; j &gt; 0 &amp;&amp; temp &lt; arr[j-1]; j--) &#123; arr[j] = arr[j-1]; &#125; arr[j] = temp; &#125; return arr;&#125; 2. 冒泡排序冒泡排序包括一个简单的双重for循环。第一次内部for循环从记录数组的底部比较到顶部，比较相邻的关键码。如果低序号的关键码比高序号的关键码大，就交换两者的顺序。一旦遇到一个最小的关键码值，这个过程使它像“气泡”一样被推到数组的顶部。第二次再重复调用上面的过程，但是，既然知道最小元素在第一次就被推到了数组的最上面，因此就没有再比较最上面两个元素的必要了。同理，每轮循环都比上一轮循环少比较一个关键码。 12345678910const bubbleSort = arr =&gt; &#123; for(let i = 0; i &lt; arr.length-1; i++) &#123; for(let j = arr.length-1; j&gt;i; j--) &#123; if(arr[j] &lt; arr [j-1])&#123; [arr[j], arr[j-1]] = [arr[j-1], arr[j]]; &#125; &#125; &#125; return arr;&#125;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://rhliu228.github.io./blog/tags/Algorithm/"}]},{"title":"JS的强制类型转换","slug":"TypeCasting","date":"2019-06-28T06:00:00.000Z","updated":"2019-07-22T13:19:54.247Z","comments":true,"path":"TypeCasting/","link":"","permalink":"https://rhliu228.github.io./TypeCasting/","excerpt":"本文是我在看了《你不知道的Javascript（中卷）》后对Javascript的强制类型转换的归纳和总结。看完书中的第一部分后，对强制类型转换和宽松相等、严格相等有了更透彻的理解。","text":"本文是我在看了《你不知道的Javascript（中卷）》后对Javascript的强制类型转换的归纳和总结。看完书中的第一部分后，对强制类型转换和宽松相等、严格相等有了更透彻的理解。将值从一种类型转换为另一种类型叫做类型转换（type casting），这是显示的情况；隐式的情况称为强制类型转换（coercion）。也可以说，类型转换发生在静态类型语言的编辑阶段，强制类型转换发生在动态类型语言的运行时。JS的强制类型转换只会返回基本类型值，不会返回对象和函数。可以从转换操作是否明显来划分显示强制类型转换和隐式强制类型转换。 1.1 ToString基本类型的字符串化规则为： null转化为”null”，undefined转化为”undefined”，true转化为”true”，false转化为”false”，数字的字符串化采用通用规则，不过极小和极大的数字使用指数形式。 对于对象来说，字符串化的背后规则是： 调用对象自身的toString方法，如果返回基本类型值，就直接对该值使用String函数，不再进行后续步骤。 如果toString方法返回的是对象，再调用原对象的valueOf方法，如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行后续步骤。 如果valueOf方法返回的是对象，则报错。 对于普通对象来说，除非自行定义，否则toString()返回内部属性[[Class]]的值，例如”[object Object]”,”[object RegExp]”。数组的默认toString方法经过了重新定义，将所有单元格字符串化后用”,”串联起来。 1.2 ToNumber将基本类型转换为数字的规则是： true转化为1，false为0。undefined转化为NaN，null转化为0。ToNumber对字符串的处理遵循数字常量的相关规则和语法。对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型，再遵循以上规则将其强制转换为数字。为了将值转换为基本类型值： 抽象操作ToPrmitive会首先检查该值是否有valueOf()方法，如果有并且返回基本类型值，就使用该返回值进行强制类型转换。 如果没有就继续使用toString()方法返回的基本类型值进行强制类型转换。 如果valueOf和toString方法均不返回基本类型值，则产生TypeError错误。 例子：12345Number([]); //0Number(&quot;&quot;); //0Number([1]); //1Number([1,2]); //NaNNumber([&apos;abc&apos;]); //NaN 1.3 ToBooleanJavascript中的值可以分为两类： 可以被强制转换为false的值 其他（被强制转换为true）的值 以下是假值： undefined null false +0, -0, NaN “” 除此之外，浏览器在某些特定情况下，在常规Javascript语法基础上自己创建了一些外来值，这些就是假值对象。假值对象看起来和普通对象差不多，但将它们强制转换为布尔值时结果为false。例如IE浏览器在新版本中为了摆脱对旧版本对象document.all的支持，将其设置为假值对象。 1.4 隐式强制类型转换显示强制转换主要指使用Number、parseInt、String和Boolean等函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。当然是否是显式，取决于个人的理解和经验。例如var a = +c; 如果你已经知道一元运算符+会将操作数显示强制转换为数字，那它就是显式的。隐式类型转换则主要是因为各种运算符对操作数的数据类型是有要求的，遇到非预期的数据类型时，会尝试自动转换数值的数据类型，这时就会出现隐式类型转换。 1.4.1 转换为字符串如果某个操作数是字符串或者通过与ToNumber抽象操作一样的处理对象方式能转换成字符串，则+号执行字符拼接操作。例如：123var a = [1,2];var b = [3,4];a + b; //&apos;1,23,4&apos; 因为数组的valueOf方法返回数组自身，无法得到基本类型值，于是转而调用toString，上例中的数组变成了”1,2”和”3,4”，+号将它们拼接后返回”1,23,4”。有一个坑常被提到，即[] + {} 和{} + []，它们分别返回”[object Object]” 和0。原因在于第二个表达式的第一个操作数{}被当作了一个空的代码块，单独执行+[]进行的是强制将[]转换为数字的操作，结果会是0。a+””和String(a)有一个细微的区别，如果a是对象，a+””会首先尝试调用a的valueOf方法，获取基本值失败后再调用toString方法。但是String(a)与之相反。 1.4.2 转换为数字除了加法运算符（+）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。 1.4.3 转换为布尔值下面情况会发生布尔值的隐式强制类型转换： if语句 for(…;…;…)中的条件判断语句 while，do while ? : 中的条件判断表达式 || &amp;&amp; 左边的操作数 这里为什么指明|| 、&amp;&amp;左边的操作数而不是整个语句呢？因为和其他语言不同，在Javascript中该整个表达式返回的并不是布尔值，它的返回值是两个操作数中的一个（且仅一个）：1234567var a = 42;var b = &quot;abc&quot;;var c = null; a||b; // 42 a&amp;&amp;b; // &quot;abc&quot; c||b; // &quot;abc&quot; c&amp;&amp;b; // null 所以与其它们为逻辑运算符，倒不如称它们为“选择器运算符”。 1.5 宽松相等和严格相等宽松相等==和严格相等===的区别在于： ==允许在相等比较中进行强制类型转换，===不允许。ES5规范的抽象相等比较算法定义了==运算符的行为。 1.5.1 有两个点需要时刻牢记： NaN不等于NaN +0等于-0 两个对象的宽松相等，仅当它们指向同一个值时视为相等。 1.5.2 字符串和数字之间的比较 如果Type(x)是数字，Type(y)是字符串，则返回x === ToNumber(y)的结果。 如果Type(x)是字符串，Type(y)是数字，则返回ToNumber(x) === y的结果。 1.5.3 其他类型和布尔类型之间的相等比较 如果Type(x)是布尔类型，则返回ToNumber(x) === y的结果。 如果Type(y)是布尔类型，则返回x === ToNumber(y)的结果。 123var x = true;var y = &apos;42&apos;;x == y; // false Type(y)是布尔值，首先将其转换为数字1，变成1 == ‘42’,二者类型不等，’42’根据1.5.2规则被转换为42，变成1==42，结果为false。由此可以看出，字符串’42’既不等于true也不等于false。 1.5.4 null和undefined的相等比较 如果x为null，y为undefined，返回true。 如果x为undefined，y为null，返回true。 除此之外其他值都不会和它们两个相等 1.5.4 对象和非对象的相等比较 如果Type(x)是数字或字符串，Type(y)是对象，则返回x === ToPrimitive(y)的结果。 如果Type(x)是对象，Type(y)是数字或字符串，则返回ToPrimitive(x) === y的结果。 1.5.5假值比较12345678&quot;0&quot; == false // truefalse == 0 // truefalse == [] // truefalse == &#123;&#125; // false&quot;&quot; == 0 // true&quot;&quot; == [] //true0 == [] // true... 还有一种极端的情况1[] == ![] // true 上述表达式会首先进行布尔值的强制类型转换，所以[] == ![]变成了[] == false,由于[] == false，所以结果为true 1.5.6总结 如果两边的值中有true或者false，千万不要用==。 如果两边有[]，””或者0，尽量不要用==。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://rhliu228.github.io./blog/tags/Javascript/"}]},{"title":"JS的类型和特殊值","slug":"Type_Value","date":"2019-06-22T01:01:00.000Z","updated":"2019-07-22T13:21:13.172Z","comments":true,"path":"Type_Value/","link":"","permalink":"https://rhliu228.github.io./Type_Value/","excerpt":"大多数开发者认为，像Javascript这样的动态语言是没有类型的，但是事实上，ECMAScript语言中所有的值都有一个对应的语言类型，ECMAScript语言类型包括：Undefined、null、Boolean、String、Object、Number、symbol。Javascript中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。","text":"大多数开发者认为，像Javascript这样的动态语言是没有类型的，但是事实上，ECMAScript语言中所有的值都有一个对应的语言类型，ECMAScript语言类型包括：Undefined、null、Boolean、String、Object、Number、symbol。Javascript中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。 1. undefined和undeclared已在作用域中声明但是还没有赋值的变量，是undefined的；相反，还没有在作用域中声明过的变量，是undeclared的。123var a;a; // undefinedb; // ReferenceError: b is not defined 这里 b is not defined 很容易让人以为是“b is undefined”,这里显示为为“b is not declared”会更准确。更让人抓狂的是typeof处理undeclared变量的方式：123var a;typeof a; // undefinedtypeof b; // undefined 对于undeclared的变量，typeof居然返回“undefined”。b虽然是一个undeclared的变量，但是typeof b并没有报错，这是因为typeof有一个特殊的安全防范机制。然而，typeof的安全机制对于在浏览器中运行的js代码来说还是很有用处的，例如：123456789// 这样会报错if(DEBUG)&#123; console.log(&apos;debug mode&apos;);&#125;// 这样是安全的if(typeof DEBUG !== &apos;undefined) &#123; console.log(&apos;debug mode&apos;);&#125; 还有要为某个缺失的功能编写polyfill：1234if(typeof atob === &apos;undefined&apos;) &#123; //这里没有用var声明变量 atob = function() &#123;/** */&#125;&#125; 如果在if语句里声明var atob，因为存在变量声明提升，该声明会被提升到作用域最顶层，即使if语句条件不成立也是如此（即浏览器本来就支持atob）。在某些浏览器中，对于特殊的内置全局变量（宿主对象），这样的重复声明会报错。还可以通过判断某个全局变量是否是全局对象的属性来避免undeclared变量的判断出错：123if(!window.atob) &#123;&#125; 与undeclared变量不同，访问不存在的对象属性不会产生Reference error。 2. 字符串JS中的字符串是不可变的，但是数组是可变的。字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串，而数组的成员函数都是在其原始值上进行操作。可以借用数组的非变异函数来处理字符串：12345var a = &apos;foo&apos;;var c = Array.prototype.join.call(a,&quot;-&quot;); //f-o-ovar d = Array.prototype.map.call(a,function(v)&#123; return v.toUpperCase() + &quot;.&quot;;&#125;); //&quot;F.O.O.&quot; 但是无法借用数组的变异函数来处理字符串，例如reverse，push等。为了实现字符串反转，可以：1var c = a.split(&quot;&quot;).reverse().join(&quot;&quot;); JS的数组变异函数包括： push() pop() shift() unshift() splice() sort() reverse() 3. undefined和nullundefined类型只有一个值，即undefined，null类型也只有一个值，即null；它们的名称既是类型也是值。它们之间有一些细微的区别： null指空值，undefined指没有值 undefined指从未赋值，null指曾经赋过值，但目前没有值 null是一个特殊关键字，不是标识符，不能被当作变量来使用和赋值，而undefined是一个标识符，可以被当作变量来使用和赋值。3.1 在非严格模式下，我们可以为全局标识符undefined赋值，1234undefined = 2; //ugly&quot;use strict&quot;;undefined = 2; //TypeError 3.2 在非严格和严格模式下，可以声明一个局部变量undefined：12var undefined = 2;console.log(undefined); //ugly 3.3 undefined是一个内置标识符，它的值为undefined，通过void运算符即可得到该值。12var a = 2;console.log(void a, a); //undefined 2 利用void运算符可以让表示式不返回任何结果，例如用于函数return语句中。1234function foo() &#123; //... return void setTimout(dosomething, 500);&#125; 4. NaNjs中有一个特殊的数字：NaN。NaN的含义是“Not a number”，如果数字运算的操作数不是数字，就无法返回一个有效的数字，这种情况下应该返回NaN。12var a = 2/&apos;foo&apos;; // NaNtypeof a === &apos;number&apos;; // true NaN是唯一一个非自反的值，即NaN !== NaN 为true。既然无法对NaN进行比较，那如何判断一个值是否是NaN呢?可以利用window对象内置的isNaN()方法。1isNaN(a); //true 但是这样方法有一个缺陷，它的检查方式是检查参数是否不是NaN，也不是数字。1234var a = 2/&apos;foo&apos;;var b = &apos;foo&apos;;window.isNaN(a); // truewindow.isNaN(b); // true 从ES6开始可以用Number.isNaN()检测，这个方法会避免上面的bug，其polyfill如下：123456789101112if(!Number.isNaN) &#123; Number.isNaN = function(n) &#123; return typeof n === &apos;number&apos; &amp;&amp; window.isNaN(n); &#125;&#125;//更简单的方法if(!Number.isNaN) &#123; Number.isNaN = function(n) &#123; return n!==n; &#125;&#125; 5. 零值Javascript中有一个常规的0（也叫做+0）和-0。-0除了可以用作常量之外，也可以是某些数学运算的返回值：12var a = 0 / -3; //-0var b = 0 * -3; //-0 加法和减法运算不会得到-0。有时候数学运算的符号位用来表示移动方向等信息。此时如果一个值为0的变量失去了它的符号位，它的方向信息就会丢失，这是-0存在的意义。根据规范，对负零进行字符串操作会返回“0”：12345678var a = 0 / -3;console.log(a); // &quot;-0&quot;//但是规范定义的返回结果是这样：a.toString(); //&quot;0&quot;a+&quot;&quot;; //&quot;0&quot;String(a); //&quot;0&quot;JSON.stringify(a); //&quot;0&quot; 此外， 0与-0进行===比较时会返回true，为了区分二者，需要做一些特殊处理：1234function isNegZero(n) &#123; n = Number(n); return (n===0) &amp;&amp; (1/n===-Infinity)&#125; 6. 特殊等式NaN和-0在相等比较时表现特殊，es6加入了Object.is()来判断两个值是否绝对相等，可以用来处理上述的特殊情况：12345678910111213if(!Object.is) &#123; Object.is = function(v1, v2) &#123; //判断是否是-0 if(v1===0 &amp;&amp; v2===0)&#123; return 1/v1 === 1/v2; &#125; //判断是否是NaN if(v1 !== v1) &#123; return v2 !== v2; &#125; return v1 === v2; &#125;&#125; 注意，能使用==和===就不要使用Object.is(),因为前者效率更高，更为通用。Object.is主要用来处理那些特殊的相等比较。 7. 值和引用在许多编程语言中，赋值和参数传递可以通过值复制或者引用复制的方法来完成，取决于使用的语法。但是在JS中，对值和引用的复制完全根据值的类型来决定，在语法上没有任何区别:简单值总是通过值复制的方式来赋值/传递；复合值总是通过引用复制的方式赋值或者传递。例如：在c语言中12345678910111213void swap(int &amp;x, int &amp;y) &#123; int temp; temp = x; x = y; y = temp;&#125;main() &#123; int a =1, b =2; swap(a,b); cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;&quot;b=&quot;&lt;&lt;b&lt;&lt;&quot;\\n&quot;; return 1;&#125;//输出 a=2 b=1 传引用调用实际上在形参位置插入的是变量本身，即值的内存位置。由于程序变量是作为内存位置来实现的，所以这些内存位置就是变量。引用相当于变量的别名，本身并不单独分配自己的内存空间，二者指向的是同一处内存。而在JS中：12345678910function foo(x) &#123; x.push(4); x; //[1,2,3,4] x = [4,5,6]; x.push(7); x; //[4,5,6,7]&#125;var a = [1,2,3];foo(a);a; //[1,2,3,4] 向函数传递a的时候，实际是将引用a的复本赋值给x，刚开始x和a指向的是同一处内存，所以x.push(4)改变的是同一个值。随后x不再指向数组[1,2,3,4],而是指向新分配的内存[4,5,6]。因为数组是复合值，所以这里默认采用引用赋值，不需要特殊的语法。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://rhliu228.github.io./blog/tags/Javascript/"}]},{"title":"webpack构建 ES2015+ module","slug":"ES6Module","date":"2019-06-20T06:00:00.000Z","updated":"2019-07-22T13:35:43.764Z","comments":true,"path":"ES6Module/","link":"","permalink":"https://rhliu228.github.io./ES6Module/","excerpt":"webpack与babel7结合，可以构建出更符合实际需求的ES2015+ module，本文从vue-cli3入手，讲述CLI工具如何结合babel、webpack等开发插件动态支持用户编译到ES2015+ ，提升代码运行效率","text":"webpack与babel7结合，可以构建出更符合实际需求的ES2015+ module，本文从vue-cli3入手，讲述CLI工具如何结合babel、webpack等开发插件动态支持用户编译到ES2015+ ，提升代码运行效率用vue CLI3搭建项目，发现该工具减少了现代前端工具在配置上的烦恼，且其基于webpack 4的预配置提供构建设置，尽可能地在工具链中加入当前和未来的最佳实践。通过vue-cli3构建项目时，它会安装Vue CLI运行时命令（vue-cli-service），选择功能插件，生成必要的配置文件，然后就可以愉快地专注于业务代码了。而且该CLI工具尊重各个第三方工具的配置文件，如果我们对这些依赖进行配置，可以很轻松地更改配置文件或者通过webpack-merge合并到最终的配置中。 当我第一次使用vue-cli3的时候，只是赞叹于它漂亮的GUI界面，并不了解vue-cli3在背后集成了什么配置。它在package.json的script入口提供了分别用于开发模式和生产模式的两个命令，当然我还采用了lint检查工具，所以一共三个命令：12345&quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build --modern&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot;&#125;, 在开发阶段，CLI工具会充分利用webpack4在development模式下内置的调试工具以及热更新、热替换等进行构建优化。而翻看npm run build后的代码，发现打包后的代码跟我自己之前手动配置的差别很大。于是我开始查阅相关资料，了解Vue CLI3背后的配置以及其原理。 观察打包后的js文件，首先会发现每个chunk都会有两个副本，其中一个副本在文件名后面添加了legacy后缀名，另一个则没有。而在html文件中，给引入带有legacy后缀js文件的script标签添加了nomodule属性，另一个script标签则添加了type=module属性。通过查阅type=module属性的作用可以了解到，在当下，对于大部分用户而言，我们根本不需要把代码编译到 ES5，不仅体积大，而且运行速度慢。我们需要做的，就是把代码编译到 ES2015+，然后为少数使用老旧浏览器的用户保留一个 ES5 标准的备胎即可。其核心原理在于依赖 &lt;script type=”module”&gt;的支持来分辨浏览器对 ES2015+ 代码的支持，并且可以用&lt;script nomodule&gt;进行优雅降级。支持 &lt;script type=”module”&gt; 的浏览器，必然支持下面的特性： async/await Promise Class 箭头函数、Map/Set、fetch 等等… 而不支持 &lt;script type=”module”&lt; 的老旧浏览器，会因为无法识别这个标签，而不去加载 ES2015+ 的代码。另外老旧的浏览器同样无法识别nomodule 属性，会自动忽略它，从而加载 ES5 标准的代码。 123&lt;script type=&quot;module&quot; src=&quot;app.js&quot;&gt;&lt;/script&gt;&lt;script nomodule src=&quot;app-legacy.js&quot;&gt;&lt;/script&gt; // legacy 是遗产的意思，在这里面是老旧的意思，理解成老旧的语法 想要支持module和nomodule的核心就是 Babel7的插件预设babel-preset-env。babel-preset-env将基于实际浏览器以及运行环境，自动确定babel插件以及polyfill，转义ES2015以及此版本以上的语法。而该preset的esmodules属性可以让我们直接编译到 ES2015+ 的语法。改造一下webpack，构建两次，分别用不同的 babel 配置，就可以编译出两份文件。CLI引入了@vue/babel-preset-app插件来提供babel-preset-env的功能，插件支持用户构建应用程序、UMD或原生web组件，其配置如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// @vue/babel-preset-app/index.js// resolve targets let targets if (process.env.VUE_CLI_BABEL_TARGET_NODE) &#123; // running tests in Node.js targets = &#123; node: &apos;current&apos; &#125; &#125; else if (process.env.VUE_CLI_BUILD_TARGET === &apos;wc&apos; || process.env.VUE_CLI_BUILD_TARGET === &apos;wc-async&apos;) &#123; // targeting browsers that at least support ES2015 classes // https://github.com/babel/babel/blob/master/packages/babel-preset-env/data/plugins.json#L52-L61 targets = &#123; browsers: [ &apos;Chrome &gt;= 49&apos;, &apos;Firefox &gt;= 45&apos;, &apos;Safari &gt;= 10&apos;, &apos;Edge &gt;= 13&apos;, &apos;iOS &gt;= 10&apos;, &apos;Electron &gt;= 0.36&apos; ] &#125; &#125; else if (process.env.VUE_CLI_MODERN_BUILD) &#123; // targeting browsers that support &lt;script type=&quot;module&quot;&gt; targets = &#123; esmodules: true &#125; &#125; else &#123; targets = rawTargets &#125; // included-by-default polyfills. These are common polyfills that 3rd party // dependencies may rely on (e.g. Vuex relies on Promise), but since with // useBuiltIns: &apos;usage&apos; we won&apos;t be running Babel on these deps, they need to // be force-included. let polyfills const buildTarget = process.env.VUE_CLI_BUILD_TARGET || &apos;app&apos; if ( buildTarget === &apos;app&apos; &amp;&amp; useBuiltIns === &apos;usage&apos; &amp;&amp; !process.env.VUE_CLI_BABEL_TARGET_NODE &amp;&amp; !process.env.VUE_CLI_MODERN_BUILD ) &#123; polyfills = getPolyfills(targets, userPolyfills || defaultPolyfills, &#123; ignoreBrowserslistConfig, configPath &#125;) plugins.push([ require(&apos;./polyfillsPlugin&apos;), &#123; polyfills, entryFiles, useAbsolutePath: !!absoluteRuntime &#125; ]) &#125; else &#123; polyfills = [] &#125; 翻看@vue/cli-service模块的源码， 我在里面找到CLI为了支持处理模板中的 module 和 nomodule 属性而引入的webpack插件：ModernModePlugin。该插件暴露了一个es6类，在该类的prototype属性上的apply方法定义如下：1234567apply (compiler) &#123; if (!this.isModernBuild) &#123; this.applyLegacy(compiler) &#125; else &#123; this.applyModern(compiler) &#125;&#125; isModernBuild属性表示当前构建是否生成ES2015+版本的代码。若是为false，则调用applyLegacy方法，并把编译器对象作为参数传递过去：12345678910111213141516applyLegacy (compiler) &#123; const ID = `vue-cli-legacy-bundle` compiler.hooks.compilation.tap(ID, compilation =&gt; &#123; compilation.hooks.htmlWebpackPluginAlterAssetTags.tapAsync(ID, async (data, cb) =&gt; &#123; // get stats, write to disk await fs.ensureDir(this.targetDir) const htmlName = path.basename(data.plugin.options.filename) // Watch out for output files in sub directories const htmlPath = path.dirname(data.plugin.options.filename) const tempFilename = path.join(this.targetDir, htmlPath, `legacy-assets-$&#123;htmlName&#125;.json`) await fs.mkdirp(path.dirname(tempFilename)) await fs.writeFile(tempFilename, JSON.stringify(data.body)) cb() &#125;) &#125;)&#125; 若为false，则调用applyModern方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// use &lt;script type=&quot;module&quot;&gt; for modern assetsdata.body.forEach(tag =&gt; &#123; if (tag.tagName === &apos;script&apos; &amp;&amp; tag.attributes) &#123; tag.attributes.type = &apos;module&apos; &#125;&#125;)// use &lt;link rel=&quot;modulepreload&quot;&gt; instead of &lt;link rel=&quot;preload&quot;&gt;// for modern assetsdata.head.forEach(tag =&gt; &#123; if (tag.tagName === &apos;link&apos; &amp;&amp; tag.attributes.rel === &apos;preload&apos; &amp;&amp; tag.attributes.as === &apos;script&apos;) &#123; tag.attributes.rel = &apos;modulepreload&apos; &#125;&#125;)// inject links for legacy assets as &lt;script nomodule&gt;const htmlName = path.basename(data.plugin.options.filename)// Watch out for output files in sub directoriesconst htmlPath = path.dirname(data.plugin.options.filename)const tempFilename = path.join(this.targetDir, htmlPath, `legacy-assets-$&#123;htmlName&#125;.json`)const legacyAssets = JSON.parse(await fs.readFile(tempFilename, &apos;utf-8&apos;)) .filter(a =&gt; a.tagName === &apos;script&apos; &amp;&amp; a.attributes)legacyAssets.forEach(a =&gt; &#123; a.attributes.nomodule = &apos;&apos; &#125;)if (this.unsafeInline) &#123; // inject inline Safari 10 nomodule fix data.body.push(&#123; tagName: &apos;script&apos;, closeTag: true, innerHTML: safariFix &#125;)&#125; else &#123; // inject the fix as an external script const safariFixPath = path.join(this.jsDirectory, &apos;safari-nomodule-fix.js&apos;) const fullSafariFixPath = path.join(compilation.options.output.publicPath, safariFixPath) compilation.assets[safariFixPath] = &#123; source: function () &#123; return new Buffer(safariFix) &#125;, size: function () &#123; return Buffer.byteLength(safariFix) &#125; &#125; data.body.push(&#123; tagName: &apos;script&apos;, closeTag: true, attributes: &#123; src: fullSafariFixPath &#125; &#125;)&#125;data.body.push(...legacyAssets)await fs.remove(tempFilename)cb()// 在 htmlWebpackPlugin 处理好模板的时候再处理下，把页面上 &lt;script nomudule=&quot;&quot;&gt; 处理成 &lt;script nomudule&gt;compilation.hooks.htmlWebpackPluginAfterHtmlProcessing.tap(ID, data =&gt; &#123; data.html = data.html.replace(/\\snomodule=&quot;&quot;&gt;/g, &apos; nomodule&gt;&apos;)&#125;) ios10.3版本有个bug，不支持 nomodule 属性，这样带来的后果就是 10.3 版本的 IOS 同时执行两份 JS 文件。有个hack写法可以解决这个问题：123456789101112131415161718192021// 这个会解决 10.3 版本同时加载 nomodule 脚本的 bug，但是仅限于外部脚本，对于内联的是没用的// fix 的核心就是利用 document 的 beforeload 事件来阻止 nomodule 标签的脚本加载(function() &#123; var check = document.createElement(&apos;script&apos;); if (!(&apos;noModule&apos; in check) &amp;&amp; &apos;onbeforeload&apos; in check) &#123; var support = false; document.addEventListener(&apos;beforeload&apos;, function(e) &#123; if (e.target === check) &#123; support = true; &#125; else if (!e.target.hasAttribute(&apos;nomodule&apos;) || !support) &#123; return; &#125; e.preventDefault(); &#125;, true); check.type = &apos;module&apos;; check.src = &apos;.&apos;; document.head.appendChild(check); check.remove(); &#125;&#125;()); 这段代码被ModernModePlugin引入并定义在常量safariFix中。参考链接： Webpack 构建策略 module 和 nomodule React 16 加载性能优化指南","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://rhliu228.github.io./blog/tags/webpack/"},{"name":"babel","slug":"babel","permalink":"https://rhliu228.github.io./blog/tags/babel/"},{"name":"vue-cli3","slug":"vue-cli3","permalink":"https://rhliu228.github.io./blog/tags/vue-cli3/"}]},{"title":"字符编码归纳","slug":"CharacterEncoding","date":"2019-06-16T12:57:35.000Z","updated":"2019-07-22T13:20:42.948Z","comments":true,"path":"CharacterEncoding/","link":"","permalink":"https://rhliu228.github.io./CharacterEncoding/","excerpt":"这篇文章主要是对ASCII，UTF-8，Unicode，GBK编码等概念进行阐述并加以区别。","text":"这篇文章主要是对ASCII，UTF-8，Unicode，GBK编码等概念进行阐述并加以区别。首先阐述三个跟字符相关的概念： 字符表：要显示的字符的集合 字符编码：字符表中的字符对应的二进制表示 字符集：定义了一种规则，将一串二进制数字解释为一个字符 例如，unicode给世界上的字符赋予一个独一无二的二进制编码，这是字符集方案，但是却没有定义字符是如何传输和存储的，而utf-8则是基于unicode的一种编码方案实现。 1. ASCIIASCII是美国制定的字符编码，使用一个字节（8bit）存储字符，一共规定了128个字符的编码，最前面的一位统一规定为0。其中0-32号字符用于特殊用途的控制码，33-127号字符表示大小写字母和数字。ASCII扩展字符集利用了字节前面的最高位，这样字符便扩展到255个，扩展的128-255字符主要用于横线、竖线、交叉等形状。 2. 中文编码 GB2312GB2312是对ASCII的中文扩展，在这种情况下，原来 0 – 127 号字符代表的含义不变，这就是半角字符。但是两个大于127的字节连在一起时，就代表GB2312编码的字符。这两个字节的范围是：第一个字节范围是[0xA1(161),0xF7(247)]，第二个字节的范围是[0xA1(161),0xFE(254)]共收录了6763个汉字，还包括拉丁字母，希腊字母和日文字符，并对ASCII字符里已有的数、标点、字母赋予两个字节的编码，这就是全角字符。、 GBKGB2312仅包含了常用汉字，没有编码生僻字以及繁体字，GBK就对其进行了扩展。只要第一个字节大于127，不管后面的字节是否大于127，就是GBK编码的字符。这两个字节的范围是：第一个字节的范围是[0x81(127),0xFE(254)]，第二个字节的范围是[0x40(64),0x7E(126)]U[0x80(128),0xFE(254)]GBK包含了GB2312的所有内容，提供了23940个编码，使用了21886个。 GB18030把两个字节在GBK中还没有用完的码位用来编码一些少数民族的语言 （GB2312,GBK,GB18030）最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里(这几种编码方案，同时用1个字节和两个字节编码)，因此写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。 3.unicode中文采用GB类进行编码，但是其他国家也同样存在着各种编码方式，这样极其容易造成乱码。而unicode对世界上大部分的文字系统进行了整理、编码。但unicode只定义了符号的二进制代码，并没有规定这个二进制编码如何存储。若是要在计算机里存储unicode编码，有两个问题： 第一个问题是如何区分unicode和ASCII，计算机如何知道三个字节代表三个符号还是一个符号。 采用定长的字节表示unicode字符，比如三个或者四个，对于只用一个字节就能表示的英文字母来说，会造成很大的存储空间浪费，每个英文字母前面必然有2到3个字节是0。这造成的结果是 ，出现了unicode的多种存储方式，导致unicode在很长时间内无法推广 4.utf-8utf的含义是UCS Transfer Format，这是随着互联网的普及而诞生的统一的编码方式。utf-8是在互联网上使用最广的一种unicode的实现方式。其他方式还包括UTF-16、UTF-32，不过在互联网上基本不用。utf-8的最大特点，就是它是一种变长的编码方式，使用1-4个字节表示一个符号，根据不同的符号变换字节长度。其编码规则是： 单字节的字符，第一位统一为0，后面七位是这个符号的unicode编码，utf-8码只占用一个字节，和ASCII码完全相同。 对于n（n&gt;1）个字节的字母,第一个字节的前n位设为1，第n+1位设置为0，后面字节的前两位都设为10，这n个字节的其余空位用来填空这个字符的unicode编码，高位用0补足。 Unicode范围 编码格式 剩余位数 000000-00007F 0xxxxxxx 7 000080-0007FF 110xxxxx 10xxxxxx 11 000800-00FFFF 1110xxxx 10xxxxxx 10xxxxxx 16 010000-10FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 21 由此可以总结出字符用UTF-8编码的规律： 4个字节的utf-8十六进制编码一定是F开头 3个字节的utf-8十六进制编码一定是E开头 2个字节的utf-8十六进制编码一定是C或者D开头 1个字节的utf-8十六进制编码一定是小于8开头 utf-16以两个字节为单位进行编码。utf-8需判断每个字节的开头标志信息，可能解析出错。而utf-16不会判断开头标志，即使错也是错一个字符，容错能力强。Javascript内部，字符以utf-16的格式存储，每个字符两个字节。对于那些需要四个字节表示的unicode字符（unicode码点大于0xFFFFF），javascript会认为它们是两个字符。不过可以参考es6中关于字符串的扩展，看看是如何解决这个问题的… 参考 字符编码笔记：ASCII，Unicode和UTF-8 —— 阮一峰","categories":[],"tags":[{"name":"字符编码","slug":"字符编码","permalink":"https://rhliu228.github.io./blog/tags/字符编码/"}]},{"title":"深入理解Javascript中的数字","slug":"NumberInJs","date":"2019-05-15T11:05:00.000Z","updated":"2019-07-22T13:21:23.799Z","comments":true,"path":"NumberInJs/","link":"","permalink":"https://rhliu228.github.io./NumberInJs/","excerpt":"我们知道，在java中，数字会分为整型和浮点型，其中浮点型区分为单精度跟双精度格式。但是在JS中，只有Number型，并不区分整型跟浮点型，数字统一采用IEEE 754标准的64位双精格式进行存储。","text":"我们知道，在java中，数字会分为整型和浮点型，其中浮点型区分为单精度跟双精度格式。但是在JS中，只有Number型，并不区分整型跟浮点型，数字统一采用IEEE 754标准的64位双精格式进行存储。 1. IEEE 754的双精度IEE754浮点数有三个基本构成：符号域(S)、指数域(E)、尾数域(M)。给定数值V，用双精度浮点数表述为1V = (-1)^S×2^*(E-1023)*1.M 其中符号域S，指数E,尾数域M定义为： 符号域S：占1位 （0代表正数，1代表负数） 指数E：占11位，也叫阶码（exponent），表示2的幂，它的作用是对浮点数加权。 阶码 = 阶码真值 + 偏移量 尾数域(M)：占52位，M是二进制小数。 顺便提一下，32位单精度由1位符号位+8位阶码+23位尾数构成。 1.1 为什么会有偏移量102311位指数表示范围为[-1024,1023], 需要引入符号位，例如将高位置1表示负数，这样0-1023表示正数，1024-2047表示负数。但这会给机器比较数字大小带来麻烦（例如机器会认为2000比1023大，但实际上2000表示的是一个负数）。为了简化操作，可以考虑整体偏移1024位，变成[0,2047],要想得到原来的数字，只需要将存储数字减少1024即可。但由于数字0和2047适用于非规格化的情况，只能特殊处理（后面会介绍什么是规格化），去除了2个数字，所以用1023作偏移量即可。这种通过偏移，使得所有的数可以不用去考虑其符号的方法叫余码系统。经过以上处理，可以将指数的真实值称为阶码真值，阶码真值与偏移量相加得到阶码，阶码就是实际存储在机器上的数字。 1.2 尾数M实际有多少位同一浮点数的表示方法有很多种，但规范一般采用科学计数法，二进制只有0和1，那么按照科学计数法，首位只可能是1，对此IEEE省略了默认的1，所以实际上有效尾数是有53位的。这时会出现一个问题， 尾数M省略的1是一定会存在的，以至于无法表示0，不过IEEE 754早就想到了这个问题。 1.3 E阶码取值E阶码分为三种情况： 规格化： S + (E!=0 &amp;&amp; E!=2047) + 1.M。此时阶码不能为0也不能为2047，只有这种情况，尾数域才会有隐含位1。 非规格化：此时E全为0，即阶码真值为-1023，如果尾数M全为0，则浮点数表示正负0；否则表示那些非常接近于0.0的数。 E全为1: 此时如果尾数域全为0，则表示Infinity和-Infinity，否则表示NaN：S + 11111111111 + (M!=0) 。 2. 数字的范围数字的范围有两个概念，一是最大正数和最小负数，二是最小正数和最大负数，即[最小负数，最大负数]并上[最小正数，最大正数]。从S、E、M三个维度看，S代表正负，E阶码值远大于M尾数个数，所以S决定大小，M决定精度。下面以E阶码分两种情况分析： 2.1 规格化规格化下，当E取最大值，即2046时，阶码真值为2046-1023=1023，从指数上看，数值范围是[-2^1023,2^1023]。JS函数计算Math.pow(2,1023)的结果是8.98846567431158e+307，如果尾数全为1，即1.1111111111 1111111111 1111111111 1111111111 1111111111 11，非常接近于2，将8.98846567431158e+307乘以2，得到的结果约等于1.7976931348623157e+308。这个值就是我们用JS常量Number.MAX_VALUE获取到的，两者非常接近，所以数字的范围是[-1.7976931348623157e+308,1.7976931348623157e+308]。如果数字绝对值超过1.7976931348623157e+308，则数字太大或者太小，在JS显示为Infinity和-Infinity，称为正向溢出。 2.2 非规格化非规格化的情况下，E取值为0，阶码真值为-1023，指数最小值是2^1023，然而尾数等于0.0000000000 0000000000 0000000000 0000000000 0000000000 01，52位尾数还能虚拟化地向右移动51位，所以最小值是2^(-1074) = Math.pow(2,2074) 约等于5e-324。JS常量Number.MIN_VALUE就等于5e-324。所以(-5e-324,5e-324)之间的数比可表示的最小的数还要小，叫反向溢出。 3.JS 整数的安全范围从M尾数分析，精度最多是53位，这决定了整数的安全范围远远小于Number.MAX_VALUE。如M取最大值：1.1111111111 1111111111 1111111111 1111111111 1111111111 11，E取52，则得到的结果是2^53-1,得到的结果是9007199254740991。而在ES6中，能够被“安全”呈现的最大整数是Number.MAX_SAFE_INTEGER，等于9007199254740991；最小整数是-9007199254740991，在ES6被定义为Number.MIN_SAFE_INTEGER。 4. 较小的数值比较二进制浮点数的最大问题，是会出现以下情况：10.1 + 0.2 === 0.3 // false 因为尾数M只有52位，这决定了0.1和0.2不是十分精确，它们的相加结果并非刚好等于0.3，而是一个比较接近的数字0.30000000000000004，所以条件判断为false。为了判断0.1+0.2和0.3是否相等，最常见的方法是设置一个误差范围值，通常称为“机器精度”，对于JavaScript来说，这个值通常是2^-52(2.220446049250313e-16)。从ES6中开始，这个值被定义在Number.EPSILON中。 5. 32位有符号整数虽然整数最大能够达到53位，但是有些数字操作（如数位操作）只适用于32位数字，所以这些操作中数字的安全范围就要小很多，变成从Math.pow(-2,31)(-2147483648)到Math.pow(2,31)(2147483648)。例如 a|0 可以将a中的数值转换为32位有符号整数 6. 32位无符号整数Javascript数组下标值的范围为0到2^32-1。对于任意给定的数字下标值，如果不在此范围内，js会将它转换为一个字符串，并将该下标对应的值作为该数组对象的一个属性值而不是数组元素。如果该下标值在合法范围内，则无论该下标值是数字还是数字字符串，都一律会被转化为数字使用，即 array[“0”] = 0 和 array[0] = 0 执行的是相同的操作。 7. 总结用数轴来表示JS中各个Number常量的大小如下： JS 32位整数 64位双精度 场景 数组索引，位运算 Number 整数范围 数组索引：[0,2^32-1]，位运算：[-2^31,2^31] [-2^53-1,2^53-1] 可表示的数范围 同上 [-1.7976931348623157e+308,-5e-324]U [5e-324, 1.7976931348623157e+308] 精度 1 2^-52 参考 深入理解IEEE 754的64位精度","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://rhliu228.github.io./blog/tags/Javascript/"}]},{"title":"深入浅出RxJS总结","slug":"RxJS","date":"2019-03-15T08:01:00.000Z","updated":"2019-06-15T11:09:28.089Z","comments":true,"path":"RxJS/","link":"","permalink":"https://rhliu228.github.io./RxJS/","excerpt":"很早就在一些博客和书籍上了解到，javascript是一门具备函数式编程特性的语言，虽然在日常工作也会接触到js的闭包，函数绑定，函数柯里化等概念，但对于函数式编程的特点和优势，一直一知半解。加之在工作中总会遇到异步处理的糟糕代码，所以前段时间花了一些功夫在阅读程墨著作的《深入浅出RxJS》上。总的来说，RxJS是Reactive Extension(也叫ReactiveX)编程理念的javascript版本。Reactive Extension是实践响应式编程的一套工具，其诞生的主要目的是解决异步处理的问题，但这并不表示Rx不适合同步的数据处理。这篇文章主要总结自己阅读《深入浅出RxJS》的一些思考，关于RxJS的具体使用可参考ReactiveX。","text":"很早就在一些博客和书籍上了解到，javascript是一门具备函数式编程特性的语言，虽然在日常工作也会接触到js的闭包，函数绑定，函数柯里化等概念，但对于函数式编程的特点和优势，一直一知半解。加之在工作中总会遇到异步处理的糟糕代码，所以前段时间花了一些功夫在阅读程墨著作的《深入浅出RxJS》上。总的来说，RxJS是Reactive Extension(也叫ReactiveX)编程理念的javascript版本。Reactive Extension是实践响应式编程的一套工具，其诞生的主要目的是解决异步处理的问题，但这并不表示Rx不适合同步的数据处理。这篇文章主要总结自己阅读《深入浅出RxJS》的一些思考，关于RxJS的具体使用可参考ReactiveX。 函数响应式编程RxJS引用了两个重要的编程思想：函数式和响应式 函数式编程函数式编程是强调使用函数来解决问题的一种编程范式。其对函数的使用有一些特殊的要求： 声明式和声明式编程相对的是命令式编程，命令式编程强调将计算逻辑以指令的方式描述出来： 1234567function double(arr)&#123; const result = []; for(let i =0; i&lt;arr.length; i++) &#123; result.push(arr[i]*2); &#125; return result;&#125; 而声明式编程则把运算过程尽量写成一系列嵌套的函数调用： 1const double = arr =&gt; arr.map(item =&gt; item * 2); 在javascript中，函数具有一等公民的地位，一个函数可以作为参数传递给另一个函数，才让map这种功能实现成为了可能。 纯函数所谓纯函数，满足了以下条件 函数的执行过程完全由输入参数决定，不会受除参数之外的任何数据影响. 函数不会修改任何外部状态，比如修改全局变量或传入的参数对象. 数据不变性程序要发生变化，不应该修改现有的数据，而是应该通过产生新的数据来体现这种变化。不可变的数据就是Immutable的数据。 顺便对比一下函数式编程和面向对象编程。这两种编程方式都可以让代码更加容易理解，但方式不同。面向对象的方法把状态的改变封装起来，外部不能直接操作数据，只能通过类提供的实例方法来读取修改数据，限制了对数据的访问方式，这就制止了毫无节制的数据修改。但是面向对象却把数据的修改历史完全隐藏起来，这种不确定性导致代码可维护性下降。而函数式编程则是尽量减少发生变化的部分，数据就是数据，函数就是函数，函数可以处理数据，通过产生新的数据作为运算结果，以此让代码更加清晰。 从本质上说，javascript并不是纯粹意义的函数式编程语言，javascript并没有强制要求数据不变性，编写的函数也不能保证没有副作用，但是javascript的函数拥有第一公民的身份，由此可以很方便地应用函数式编程的许多思想。More info:函数式编程入门教程函数式编程初探 响应式编程 响应式编程是一种面向数据流和变化传递的编程范式。 数据流可以通过多种方式创造出来，流对象中流淌的是数据，数据流会通过各种管道，这些管道会对数据进行各种转化处理，RxJS的核心就是使用和组合各种操作符，构成管道，对流经其中的数据进行处理。 Observable 和ObserverObserver和Obeservable是RxJS的两个重要概念。Obeservable就是“可被观察的对象”，而Observer就是观察者，连接两者的桥梁就是Observable对象的函数subscribe。每个Observable对象，代表的就是在一段时间范围内发生的一系列事件。RxJs结合了观察者模式和迭代器模式，其中的Observable等同于： 1Observable = Publisher + Iterator 观察者模式观察者模式将逻辑分为发布者和观察者，其中生产者只负责产生事件，它会通知所有注册挂上号的观察者，而不关心这些观察者如何处理这些事件，相对的，观察者可以被注册上某个发布者，只管接收到事件之后就处理，而不关心这些数据是如何产生的。在RxJS的世界中，Observable对象就是一个发布者，通过Observable对象的subscribe，可以把这个发布者和某个观察者连接起来。观察者使得复杂的问题被分解成三个小问题： 如何产生事件，这是发布者的责任，在RxJS中是Observable对象的工作。 如何响应事件，这是观察者的责任，在RxJS中由subscribe的参数来决定。 什么样的发布者关联什么样的观察者，也就是何时调用subscribe。 迭代器模式迭代器指的是能够遍历一个数据集合的对象，数据集合的实现方式有很多，比如数组，单向链表等，迭代器的作用就是提供一个通用的接口，让使用者完全不用关心这个数据集合的集合的实现方式。迭代器的另一个名字叫游标（cursor）,就像一个移动的指针一样，从集合中的一个元素移动到另一个元素，完成对整个集合的遍历。迭代器的实现方式有很多，通常包含以下几个函数： getCurrent，获取当前被游标指向的元素 moveToNext，将游标移动到下一个元素，调用这个函数之后，getCurrent获得的元素就会不同 isDone， 判断是否已经遍历完所有的元素上面说的三个函数，是“拉”式迭代器的实现，而RxJs实现的是“推”式的迭代器的实现。因为在RxJS中，作为迭代器的使用者，并不需要主动从Observable中“拉”数据，而是只要subscribe上Observable对象之后，自然就能接收到消息的推送，这就是观察者模式和迭代器模式结合的强大之处。下面是一段代码： 12345const iterator = getIterator();while(!iterator.isDone())&#123; console.log(iterator.getCurrent()); iterator.moveToNext();&#125; 以下这段代码说明了Observable在完结，出错处理以及向下游传递数据时如何通知下游。1234567891011121314151617181920212223242526272829303132333435363738const onSubscribe = observer =&gt; &#123; let number = 1; const handle = setInterval(() =&gt; &#123; observer.next(number++); &#125;,1000); return &#123; unsubscribe: () =&gt; &#123; clearInterval(handle); &#125; &#125;&#125;// 完结和出错处理const onSubscribe = observer =&gt; &#123; observer.next(1); // 向下游传递完结信号 observer.complete(); // or 向下游传递错误信号 //注意，一个Observable对象只能有一种终结状态，要么是完结，要么是出错，所以调用了complete之后再调用error函数是无法引发下游的错误处理函数调用的，反之亦然。 //observer.error(&apos;wrong&apos;);&#125;const source$ = new Observable(onSubscribe);const theObserver = &#123; next: item =&gt; console.log(item), error: err =&gt; console.log(err), complete: () =&gt; console.log(&apos;No more Data)&#125;const subscription = source$.subscribe(theObserver);// 也可以简写为// const subscription = source$.subscribe(// item =&gt; console.log(item),// err =&gt; console.log(err),// complete: () =&gt; console.log(&apos;No more Data)//);setTimeout(() =&gt; &#123; //退订Observable subscription.unsubscribe();&#125;,3500); 操作符一个Observable对象代表的是一个数据流，实际工作中，产生Observable对象并不是每次都直接调用Observable构造函数来创建数据流对象，Rxjs已经贴心地为我们实现了常用的创建类操作符。这里说的创造，并不只是说返回一个Observable对象，而是指这些操作符不依赖于其他Observable对象，这些操作符可以凭空或者根据其他数据源（外部js事件，promise，ajax等）创造出一个Observable对象。事实上，对于复杂情况，并不会创建了一个数据流之后就直接subscribe一个Observer，往往需要各类操作符对数据流做一系列的处理，再交给Observer，就像一个管道，数据从管道的一段流入，途经管道的各个环节，位于管道末端的Observer只需要处理能够走到终点的数据。 组成数据管道的元素就是操作符，操作符的本质是返回一个Observable对象的函数。对于每一个管道，链接的就是上游和下游。 在数据管道中流淌的数据就像水，从上游流向下游。对于一个操作符来说，上游可能是一个数据源，也可能是其他操作符，下游可以是最终的观察者，也可能是另一个操作符。每个操作符都会满足 返回一个全新的Observable对象 对上游和下游的订阅和退订处理。 处理异常情况 及时释放资源 操作符分类功能分类根据功能，操作符可以分为以下类别 创建类，包括create, of, range, generate, repeat和repeatWhen, empty, throw, never, inteval和timer, from, from Promise, from event和fromEventPattern, ajax, defer. 转化类，包括map, mapTo, pluck, windowTime、 windowCount、windowWhen、windowToggle、和window, bufferTime、bufferCount、bufferWhen、bufferToggle和buffer, concatMap、mergeMap、switchMap、exhaustMap, scan和mergeScan 过滤类，包括filter, first, last, take, takeLast, takeWhile和takeUntil, skip, skipwhile和skipUntil, throttleTime、debouceTime和auditTime, throttle、debouce和audit, sample和sampleTime, distnct, distinctUntilChanged和distinctUntilKeyChanged, ignoreElements, elementAt, single 合并类，包括concat和concatAll, merge和mergeAll, zip和zipAll, combineLatest、combineAll和withLatestFrom, race, startWith, forkJoin, switch和exhaust 多播类，包括multicast, publishLast, publishReplay, publishBehavior 错误处理类，包括catch, retry和retryWhen, finally 辅助工具类，包括concat, max和min, Reduce, every, find和findIndex, isEmpty, defaultEmpty 静态和实例分类 操作符还可以从存在形式进行分类，具体来说就是操作符的实现函数和Observable类的关系。对于定义在Observable类的静态函数，我们称之为静态操作符，而定义在由Observable类prototype属性指向的原型对象上的实例函数，则被称为实例操作符。在链式调用中，静态操作符只能出现在首位，而实例操作符可以出现在任何位置。有些操作符既可以作为Observable类的静态方法，又可以作为Observable对象的实例方法，比如merge。（此处涉及javascript的原型链知识以及es6的class，建议不太了解的读者查阅其他资料了解） 操作符的实现操作符函数实现1234567891011121314151617181920212223242526function map(project) &#123; return new Observable(observer =&gt; &#123; const sub = this.subscribe(&#123; next: value =&gt; &#123; //处理异常情况 try&#123; observer.next(project(value)) &#125; catch(err) &#123; observer.error(error); &#125; &#125;, error: error =&gt; observer.error(error), complete: () =&gt; observer.complete() &#125;); //订阅和退订处理 return &#123; unsubscribe: () =&gt; &#123; sub.unsubscribe(); &#125; &#125; &#125;)&#125;//使用es6箭头函数将会出错，因为此时this将直接绑定为定义函数环境下的this//const map = (project) =&gt; &#123; //这个函数体内的this并不是Observable对象本身//&#125; 可以看到，map利用new关键字创造了一个Observable对象，函数返回的结果就是这个对象，如此一来，map可以链式调用，可以在后面调用其他的操作符，或者调用subscribe增加Observer。这里的this代表的是上游的Observer对象，所以，可以直接使用subscribe订阅其中的事件，对于next事件，调用project函数，把推送的数据做映射，然后传递给下游，对于error和complete事件，map全部转手给下游处理。 操作符关联Observablemap函数编写完毕之后，需要将这个函数与observable关联起来。 给Observable打补丁打补丁就像是给Observable类添加一点功能。map操作符需要一个上游Observable对象，所以它是一个实例操作符，需要赋值给Observable的prototype：1Observable.prototype.map = mao; 如果是一个静态操作符，则直接赋给Observable类的某个属性。 使用bind绑定Observable对象有时候，我们并不希望一个操作符影响所有的Observable对象，为了不覆盖RxJS的map操作符，可以让自定义的操作符只对指定的Observable对象可用，这时可以用bind：1const result$ = map.bind(source$)(x =&gt; x*2); 也可以用call：1const result$ = map.call(source$,x =&gt; x*2); 使用bind有一个缺点，就是上游Observable只能作为操作符函数的参数，这样没法用链式调用，比如，想要连续使用两个map：1const result$ = map.bind(map.bind(source$)(x =&gt; x*2))(x =&gt; x+1); 为了克服这个缺点，可以使用“绑定操作符”，绑定操作符是两个冒号，运算的时候绑定操作符后面的函数，但是保证函数运行时this是绑定操作符前面的对象，这样就可以使用链式调用：1const result$ = source$::map(x=&gt;x*2)::map(x=&gt;x+1); 绑定操作符并不是es6的标准语法，但它会出现在未来的es版本中，浏览器并不支持这种操作符。 使用liftRxJS v5对架构有很大的调整，很多操作符都会用一个神奇的lift函数实现，lift的含义是“提升”，功能是把Observable对象提升一个层次，赋予更多功能。lift是Observable的实例函数，它会返回一个新的Observable对象，通过传递给lift的函数参数可以赋予这个新的Observable对象特殊功能。使用lift实现map： 123456789101112131415function map(project) &#123; return this.lift(function(source$) &#123; return source$.subscribe(&#123; next: value =&gt; &#123; try&#123; this.next(project(value)) &#125; catch(err) &#123; this.error(error); &#125; &#125;, error: err =&gt; this.error(err), complete: () =&gt; this.complete(), &#125;); &#125;);&#125; this代表的是Observer对象，参数source$代表上游的Observable对象。 改进的操作符定义操作符和Observable关联的缺陷js模块导入的代码并不都会被执行，打包工具（rollup，webpack等）的Tree shaking主要用于在js代码打包过程中去除无用的死代码，减少js代码的体积。RxJS中操作符挂在Observable类上或者Observable.prototype上，赋值给Observable类和Observable.prototype上的某个属性在Tree shaking看来就是就是有用的代码，所以，所有的操作符，不管真实运行时是否被调用，都会被Tree shaking认为是有用的代码，不会被当作死代码删除。比如，代码引入interval和map两个操作符：12import &apos;rxjs/add/observable/interval&apos;;import &apos;rxjs/add/operator/map&apos;; 假如在程序中interval和map并没有被调用过，这两个操作符也不会被当作死代码。除此之外，用给Observable打补丁的方式导入操作符，每个文件模块影响的都是全局唯一的那个Observable，极其容易因为代码耦合造成问题。 使用call来创建库摒弃给Observable类打补丁的做法，对于静态操作符，直接使用该函数即可，对于实例操作符，使用bind/call方法，让一个操作符只对一个具体的Observable对象生效。12345678910//留意导入路径的不同import &#123;Observable&#125; from &apos;rxjs/Observable&apos;;import &#123;of&#125; &apos;rxjs/observable/of&apos;;import &#123;map&#125; &apos;rxjs/operator/map&apos;;Observable.prototype.double = function() &#123; return this::map(x =&gt; x*2);&#125;const source$ = of(1,2,3);const result$ =source$.double();result$.subscribe(value =&gt; console.log(value)); 上述代码导入的of和map是两个独立的函数，RxJs传统的打补丁的方式，使用的也是observable和operator目录下的代码，例如rxjs/add/observable/of.js文件所做的工作就是导入rxjs/observable/of.js，并把导入的函数挂载到Observable类上：1234&quot;use strict&quot;;var Observable__1 = require(&apos;../../Observable&apos;);var of_1 = require(&apos;../../observable/of&apos;);Observable__1.Observable.of = of_1.of; 使用bind和call方法，避免了Observable被污染的问题。 lettable和pipeable操作符使用bind和call，每个函数体内依然需要访问this，访问this的函数并不是纯函数。另外，使用call也会让RxJS的代码失去类型检查的优势。从RxJS v5.5.0开始，加入了pipeable操作符，也曾称为lettable操作符。 let在lettable操作符提出之前，let操作符就存在了，它接受一个函数作为参数，该函数需要接收一个Observable对象作为上游Observable。123456789import &#123;Observable&#125; from &apos;rxjs/Observable&apos;;import &apos;rxjs/add/observable/of&apos;;import &apos;rxjs/add/operator/map&apos;;import &apos;rxjs/add/operator/let&apos;;const source$ = Observable.of(1,2,3);//double$是一个纯函数，map直接作用于参数obs$const double$ = obs$ =&gt;obs$.map(x=&gt;x*2);const result$ = source$.let(double$);result$.subscribe(console.log); 改进以上代码，让map返回一个函数，从而可以作为let操作符的参数1234567891011121314151617181920function map(project) &#123; return function(obs$)&#123; return new Observable(observer =&gt; &#123; return obs$.subscribe(&#123; next: value =&gt; &#123; //处理异常情况 try&#123; observer.next(project(value)) &#125; catch(err) &#123; observer.error(error); &#125; &#125;, error: error =&gt; observer.error(error), complete: () =&gt; observer.complete() &#125;); &#125;) &#125;&#125;const result$ = source$.let(map(x=&gt;x*2)); let的作用是把map函数引入到链式调用之中，起到连接上游下游的作用。这里的map函数执行不再是返回一个Observable对象，而是返回一个函数，这个函数才返回Observable对象。，map的实现也看不到对this的访问，在数据管道中上游Observable对象以参数形式传入，而不是靠this获取，让map成为了一个纯函数。从RxJS v5.5.0开始，加入了pipeable操作符，大部分操作符都有pipeable操作符实现，除了： 静态操作符 拥有多个上游Observable对象的操作符 因为每一个lettable操作符都是纯函数，且不会作为补丁挂在Observable类上，Tree shaking就能够找到根本不会被用到的操作符并将其去除。但是导入let这个操作符，却需要使用传统的打补丁的形式，所以RxJS让Observable类自带了一个新的操作符，名叫pipe，可以满足let的功能，却不需要像使用let一样导入模块，任何Observable对象都支持pipe1const result$ = source$.pipe(map(x=&gt;x*2)); pipe还具有管道的功能，可以把多个lettable操作符连接起来：123456789import &#123;of&#125; &apos;rxjs/observable/of&apos;;//留意lettable操作符的引入路径import &#123;map,filter&#125; &apos;rxjs/operators&apos;;const source$ = of(1,2,3);const result$ = source$.pipe( filter(x =&gt; x%2 ===0), map(x =&gt; x*2));result$.subscribe(console.log); 有四个操作符比较特殊，传统的操作符名称和pipeable操作符名称不同： do catch switch finally这四个操作符名称都是js的关键字，以打补丁的方式赋值为Observable.prototype对象某个属性值没有问题，但是不能作为函数的标识符出现，这四个操作符对应的lettable操作符分别是 tap catchError switchAll finalize 多播在RxJs中，Observable和Observer的关系，就是前者在播放内容，后者在收听内容，播放内容的方式可以分为三种： 单播（unicast） 广播（broadcast） 多播（multicast）单播是一对一的关系，一个播放者对应一个接听者，广播把消息传播给所有接听者，多播则是有选择性地把消息传递给有需要的接听者。RxJS对单播是绝对支持的，而广播则不是RXJS支持的目标，广播已经有很多现成的解决方法，例如nodeJs中的EventEmitter。 Hot和Cold数据流的差异如果每一次观察者对Observable对象进行subscribe，都会产生一个全新的数据序列的数据流，这样的Observable对象被称为cold observable。RxJS的大部分创建类操作符创建出来的都是cold observable对象，例如inteval，range等。下面是一个单播的例子：123456789101112131415import &#123;interval&#125; &apos;rxjs/observable/of&apos;;import &#123;take&#125; &apos;rxjs/operators&apos;;const tick$ = interval(1000).pipe(take(3));tick$.subscribe(value=&gt;console.log(&apos;observer 1: &apos; + value));setTimeout(() =&gt; &#123; tick$.subscribe(value=&gt;console.log(&apos;observer 2: &apos; + value));&#125;,2000);//console//observer 1: 0//observer 1: 1//observer 2: 0//observer 1: 2//observer 2: 1//observer 2: 2 你可能会以为输出下面的结果：12345//observer 1: 0//observer 1: 1//observer 2: 1//observer 1: 2//observer 2: 2 但是，interval操作符产生的是一个cold observable对象，每次对上游的subscribe都会产生一个新的生产者。而对于一个hot observable，概念上有一个独立于Observable对象的生产者，这个生产者的创建与subscribe的调用没有关系，subscribe的调用只是让Observable对象连接上生产者而已。RxJs中有一些操作符产生的是Hot Observable： fromPromise fromEvent fromEventPattern 这些产生hot observable对象的操作符数据源都在外部，真正的数据源和有没有Observer没有任何关系。而真正的多播，则是不管有多少Observer进行subscribe，推给Observer的数据都是一样的数据源，满足这种条件的，就是hot observable。hot observable和cold observable都具有“懒”的性质，两者的数据管道内逻辑都只有订阅者存在时才执行，但是cold Observable更“懒”，如果没有订阅者，连数据都不会真正产生；对于hot observable来说，没有订阅者的情况下，数据依旧产生，只是不传入数据管道。所以cold observable实现的是单播，而hot observable实现的是多播。 Subject有时候，我们也希望对cold observable实现多播。要把一个cold observable对象转换成一个hot observable，并不是去改变cold observable本身，而是产生一个新的observable对象，包装之前的cold observable对象，这样在数据流管道中，新的observable就成为了下游。要实现这个转化，很明显需要一个“中间人”做串接的事情： 中间人需要提供subscribe方法，让其他人能够订阅自己的数据源 中间人能够有办法接收推送的数据，包括cold observable推送的数据RxJS中，提供了subject类型，subject既有observable的接口，也具有observer的接口。123456789101112import &#123;Subject&#125; from &apos;rxjs/Subject&apos;;import &#123;interval&#125; &apos;rxjs/observable/interval&apos;;import &#123;map&#125; &apos;rxjs/operators&apos;;const subject = new Subject();subject.pipe(map(x=&gt;x*2)).subscribe( value =&gt; console.log(value), err =&gt; console.log(err), () =&gt; console.log(&apos;on complete&apos;));subject.next(1);subject.next(2);subject.complete(); 一个subject对象是一个Observable，所以可以在后面链式调用任何操作符，也可以调用subscribe来添加Observer。一个subject对象同时也是一个Observer，所以也支持next，error和complete方法。 用Subject实现多播12345678910import &#123;Subject&#125; from &apos;rxjs/Subject&apos;;import &#123;interval&#125; &apos;rxjs/observable/interval&apos;;import &#123;map&#125; &apos;rxjs/operators&apos;;const tick$ = interval(1000).pipe(take(3));const subject = new Subject();tick$.subscribe(subject);subject.subscribe(value=&gt;console.log(&apos;observer 1: &apos; + value));setTimeout(() =&gt; &#123; subject.subscribe(value=&gt;console.log(&apos;observer 2: &apos; + value));&#125;,1500); 只需要让Subject对象居于cold observable和observer之间。但是很可惜subject并不是一个操作符，所以无法链式调用，不过可以创建一个新的操作符来达到链式调用的效果:1234567891011Observable.prototype.makeHot = function() &#123; const cold$ = this; const subject = new Subject(); cold$.subscribe(subject); return subject;&#125;const hotTick$ = interval(1000).pipe(take(3)).makeHot();hotTick$.subscribe(value=&gt;console.log(&apos;observer 1: &apos; + value));setTimeout(() =&gt; &#123; hotTick$.subscribe(value=&gt;console.log(&apos;observer 2: &apos; + value));&#125;,1500); 这段代码有个漏洞，可以直接调用makeHot返回的subject对象的next，error或者complete方法来影响下游：1234const hotTick$ = interval(1000).pipe(take(3)).makeHot();hotTick$.complete();//下面的Observer将不会收到任何消息hotTick$.subscribe(value=&gt;console.log(&apos;observer 1: &apos; + value)); subject对象是不能重复使用的，一个subject对象一旦被调用了complete或者error函数，那么，它作为observable的生命周期也就结束了，后续再想利用这个subject对象传递数据给下游，就像泥牛如大海，没有任何反应。为了杜绝这种可能性，对makeHot进行改进，让它返回一个纯粹的Observable对象:123456Observable.prototype.makeHot = function() &#123; const cold$ = this; const subject = new Subject(); cold$.subscribe(subject); return Observable.create((observer) =&gt; subject.subscribe(observer));&#125; makeHot并不是直接返回Subject对象，而是返回一个新的Observable对象，这样就避免了subject直接暴露给外部。 subject可以有多个上游，如果一个subject订阅多个数据流，起到的作用就是把多个数据源的内容汇聚到一个observable，但是这种使用方式却可能引发意想不到的结果。假设其中一个上游调用了subject对象的complete函数，那即使其他上游的数据还没推送完，subject也会因为生命周期的结束，无法再把其他数据推送给下游。任何一个上游数据的完结或者出错都可以终结subject对象的生命，让subject来做合并数据流的工作并不合适，应该让merge来做。当subject有多个observer时，如果某个observer产生了一个错误异常，而且这个异常没有被observer处理，那subject的其他observer都会失败。12345678910111213141516const tick$ = interval(1000).pipe(take(3));const subject = new Subject();tick$.subscribe(subject);const throwOnUnluckyNumber = value =&gt; &#123; if(value==4)&#123; throw new Error(&apos;unlucky number 4&apos;); &#125; return value;&#125;subject.pipe(map(throwOnUnluckyNumber)).subscribe( value=&gt;console.log(&apos;observer 1: &apos; + value))subject.subscribe( value=&gt;console.log(&apos;observer 2: &apos; + value), err=&gt;console.log(err)) 1号observer在遇到数字4的时候遇到错误异常，2号observer因为1号observer没有优雅地处理错误，也被牵连，因为subject对象由于下游1号Observer没有处理错误而被破坏了。可以想象，Subject为了给所有observer推送数据，会有类似的代码：123for(let observer of allObservers)&#123; observer.next(data);&#125; 为了解决这个问题，好的编程实践是让所有的observer都具备对异常错误的处理。12345678subject.pipe(map(throwOnUnluckyNumber)).subscribe( value=&gt;console.log(&apos;observer 1: &apos; + value), err=&gt;console.log(&apos;observer 1 on error: &apos; + err))subject.subscribe( value=&gt;console.log(&apos;observer 2: &apos; + value), err=&gt;console.log(&apos;observer 2 on error: &apos; + err)) 支持多播的操作符RxJs提供了支持多播的一系列操作符，其中最基础的是 multicast share publish multicast是一个实例操作符，能够以上游的Observable为数据源产生一个新的hot observable对象：1const hotSource$ = coldSource$.multicast(new Subject); multicast接收一个subject对象或者一个返回subject对象的函数（可以在subject对象生命终结时重新subscribe上游）作为参数，返回的是一个Observable对象，不过这个对象比较特殊，是Observable子类ConnectableObservable的实例对象。这种对象包含一个connect函数，connect的作用是触发multicast用Subject对象去订阅上游的Observable，如果不调用这个函数，这个ConnectableObservable将不会从上游那里得到任何数据。除此之外，ConnectableObservable还支持自动计数，对Observer的个数进行计数，当第一个Observer对象被添加时，主动去订阅上游，当最后一个Observer退订时，就让中间人Subject退订上游的Cold Observable。这个功能可以借助ConnectableObservable对象的函数refCount实现。除了第一个参数指定一个Subject对象或者指定一个产生Subject对象的工厂方法，multicast还支持第二个参数：selector，这个参数是一个可选参数，它可以使用上游数据任意多次，但不会重复订阅上游数据流。一旦指定selector参数，multicast将不会返回ConnectableObservable对象，而是用selector函数来产生一个Observable对象。selector函数有一个参数shared，这个参数就是multicast第一个参数代表的Subject或者使用工厂方法返回的Subject对象。123456789101112131415161718192021const coldSource$ = interval(1000).pipe(take(3));const selector = shared =&gt; &#123; return shared.pipe(concat(of(&apos;done)));&#125;const tick$ = coldSource$.pipe(multicast(new Subject(),selector));tick$.subscribe( value=&gt;console.log(&apos;observer 1: &apos; + value), err=&gt;console.log(&apos;observer 1 on error: &apos; + err));setTimeout(() =&gt; &#123; tick$.subscribe( value=&gt;console.log(&apos;observer 2: &apos; + value), err=&gt;console.log(&apos;observer 2 on: error: &apos; + err) );&#125;);//console//observer 1: 0//observer 1: 1//observer 1: 2//observer 1: done//observer 2: done publish完全是通过multicast来实现的 1234567function(selector)&#123; if(selector)&#123; return this.multicast(()=&gt;new Subject(),selector); &#125;else&#123; return this.multicast(new Subject); &#125;&#125; shared完全是通过multicast来实现的 123Observable.prototype.shared = function shared() &#123; return this.multicast(() =&gt; new Subject()).refCount();&#125; 除了以上这几个基础的多播操作符外，RxJS还支持三个高级多播操作符： publishList publishReplay publishBehavior关于它们的使用可以自行查阅官网 总结《深入浅出RxJS》这本书较为系统的介绍了RxJS的核心特性和各类操作符，并且书该书结合弹珠图，将代码例子形象生动地描述清楚，给读者提供了很好的入门教程。个人觉得从书中前三章中得到的收获最大，从中了解到RxJS的代码架构、函数式编程的理念和如何实现操作符。后面介绍操作符用途的章节略显冗长，不过其中有些代码的例子特别贴切和生动，让人有眼前一亮的快感。可以看出作者对RxJS各类操作符的了解是非常深刻的。 例如，讲解RxJS的高阶observable，所谓高阶，指的是该Observable返回的依旧是Observable，这样能够管理多个数据流，将管理数据和管理数据流归一化，类似于高阶函数，高阶函数的参数或者返回值是一个函数。这时就需要一些操作符能够组合或者处理这些高阶Observable，将其“砸平”，常见的有合并类高阶操作符concatAll，mergeAll，以及高阶的map等。为了说明高阶map运算符concatMap的用途，作者列举了实现网页拖拽的例子。网页应用中，拖拽就是用户的鼠标在某个dom元素上按下去，然后拖动这个元素，最后松开鼠标的过程，这个过程是重复的，拖拽涉及的事件包括mousedown，mouseup和mousemove，使用传统方式，基本上就是当mousedown事件发生时，用一个变量标识当前进入拖拽状态，然后监听mousemove事件，移动dom元素位置，当mouseup事件发生时，改变状态变量使之标记为“离开拖拽”，等待下一次mousedown事件的发生。这个过程可以看成是多个由mousedown事件引发的数据流序列，每个序列内部又是以mouseup结束的mousemove数据序列。这些序列相互之间不可能交叉重复，这时可以考虑使用高阶map操作符concatMap实现这个例子。详细的代码可参考concatMap example RxJS还有一些非常有意思的特性，包括Scheduler，单元测试等，这些并未在这篇博客中体现，读者可以根据自身需要去了解。 可以得出，只有在项目中使用RxJS，经过大量实践，才能真正掌握RxJS这套工具。我乖乖地合上了这本书，打算找个项目练练手去了。 版本《深入浅出RxJS》这本书的代码依赖的是RxJs v5.5.0之前的版本，大部分操作符都是采用给Observable类打补丁的形式引用的，我在尝试看这本书的时候，RxJS的版本已经是V6.3.3了，在该版本中，将打补丁的形式完全移除，将所有实例操作符改成了pipeable操作符，其目录存放在”rxjs/operators”，静态操作符直接使用，其目录就在”rxjs/index.js”。","categories":[],"tags":[{"name":"函数式编程","slug":"函数式编程","permalink":"https://rhliu228.github.io./blog/tags/函数式编程/"},{"name":"响应式","slug":"响应式","permalink":"https://rhliu228.github.io./blog/tags/响应式/"}]}]}